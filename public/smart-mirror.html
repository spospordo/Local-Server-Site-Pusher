<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Mirror Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body.theme-light {
            background: #f5f5f5;
            color: #333;
        }

        .dashboard-container {
            display: grid;
            /* Grid dimensions are set dynamically via JavaScript */
            gap: 20px;
            padding: 20px;
            height: 100vh;
            width: 100vw;
        }

        .widget {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Enforce strict grid sizing - prevent content from expanding widget */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        body.theme-light .widget {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .widget-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .widget-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* Enforce content containment within widget bounds */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        /* Clock Widget */
        .clock-time {
            font-size: 4rem;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .clock-time-24h {
            font-size: 2.4rem; /* 60% of main clock size */
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            margin-top: 8px;
            opacity: 0.6;
            color: #999;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        body.theme-light .clock-time-24h {
            color: #666;
        }

        .clock-date {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        /* Additional timezone styles */
        .clock-additional-timezone {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.theme-light .clock-additional-timezone {
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        
        .clock-additional-city {
            font-size: 1rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }
        
        .clock-additional-time {
            font-size: 1.4rem;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        /* Calendar Widget */
        .calendar-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            /* Ensure calendar container doesn't expand beyond widget */
            min-height: 0;
        }

        .calendar-month-view {
            flex-shrink: 0;
        }

        .calendar-header {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
            text-align: center;
            font-size: 0.85rem;
        }

        .calendar-day-name {
            font-weight: 600;
            padding: 4px 2px;
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .calendar-day {
            padding: 6px 2px;
            border-radius: 4px;
            font-size: 0.85rem;
            min-height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-day.today {
            background: rgba(102, 126, 234, 0.6);
            font-weight: 700;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.4);
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.has-event {
            position: relative;
        }

        .calendar-day.has-event::after {
            content: 'â€¢';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(102, 126, 234, 0.8);
            font-size: 0.8rem;
        }

        .calendar-events {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
            min-height: 0; /* Critical for flex child scrolling */
            scroll-behavior: smooth;
        }

        .calendar-events::-webkit-scrollbar {
            width: 6px;
        }

        .calendar-events::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.3);
            border-radius: 3px;
        }

        body.theme-light .calendar-events::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
        }

        .calendar-event {
            background: rgba(102, 126, 234, 0.2);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 0.85rem;
            border-left: 3px solid rgba(102, 126, 234, 0.6);
        }

        .calendar-event.all-day {
            border-left-color: rgba(255, 183, 77, 0.8);
            background: rgba(255, 183, 77, 0.15);
        }

        .calendar-event-time {
            font-weight: 600;
            margin-right: 8px;
            color: rgba(102, 126, 234, 0.9);
        }

        .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 183, 77, 0.9);
        }

        body.theme-light .calendar-event-time {
            color: rgba(102, 126, 234, 1);
        }

        body.theme-light .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 152, 0, 1);
        }

        .calendar-event-title {
            font-weight: 500;
        }

        .calendar-event-location {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 3px;
        }

        .calendar-event-description {
            font-size: 0.75em;
            opacity: 0.6;
            margin-top: 4px;
            line-height: 1.3;
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-error {
            opacity: 0.6;
            text-align: center;
            padding: 10px;
            font-size: 0.9rem;
        }

        .calendar-warning {
            background: rgba(255, 183, 77, 0.2);
            border-left: 3px solid rgba(255, 183, 77, 0.6);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        /* Responsive calendar layout for different widget sizes */
        @media (min-width: 1px) {
            /* Small widgets - reduce clock size */
            .widget[data-grid-width="1"] .clock-time {
                font-size: 2rem;
            }

            .widget[data-grid-width="1"] .clock-time-24h {
                font-size: 1.2rem; /* 60% of small widget clock size */
            }
            
            .widget[data-grid-width="1"] .clock-date {
                font-size: 0.8rem;
            }
            
            .widget[data-grid-height="1"] .clock-time {
                font-size: 2.5rem;
            }

            .widget[data-grid-height="1"] .clock-time-24h {
                font-size: 1.5rem; /* 60% of medium widget clock size */
            }
            
            .widget[data-grid-height="1"] .clock-date {
                font-size: 0.9rem;
            }
            
            .widget[data-grid-width="1"] .clock-additional-city {
                font-size: 0.7rem;
            }
            
            .widget[data-grid-width="1"] .clock-additional-time {
                font-size: 1rem;
            }
            
            .widget[data-grid-height="1"] .clock-additional-city {
                font-size: 0.8rem;
            }
            
            .widget[data-grid-height="1"] .clock-additional-time {
                font-size: 1.1rem;
            }

            /* Small widgets - reduce calendar grid size */
            .widget[data-grid-width="1"] .calendar-grid,
            .widget[data-grid-height="1"] .calendar-grid {
                font-size: 0.7rem;
                gap: 2px;
            }

            .widget[data-grid-width="1"] .calendar-day,
            .widget[data-grid-height="1"] .calendar-day {
                padding: 3px 1px;
                font-size: 0.7rem;
                min-height: 1.2rem;
            }

            .widget[data-grid-width="1"] .calendar-header,
            .widget[data-grid-height="1"] .calendar-header {
                font-size: 0.9rem;
                margin-bottom: 5px;
            }

            .widget[data-grid-width="1"] .calendar-day-name,
            .widget[data-grid-height="1"] .calendar-day-name {
                font-size: 0.6rem;
            }

            /* Medium and large widgets - standard sizing */
            .widget[data-grid-width="2"] .calendar-events,
            .widget[data-grid-width="3"] .calendar-events,
            .widget[data-grid-width="4"] .calendar-events {
                min-height: 120px;
            }

            /* Wide widgets - use horizontal layout if short */
            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-container,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-container {
                flex-direction: row;
                gap: 15px;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-month-view,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-month-view {
                flex-shrink: 0;
                width: 45%;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-events,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-events {
                width: 55%;
                min-height: 0;
            }

            /* Responsive weather widget sizing */
            .widget[data-grid-width="1"] .weather-temp {
                font-size: 2rem;
            }
            
            .widget[data-grid-height="1"] .weather-temp {
                font-size: 2.5rem;
            }
            
            .widget[data-grid-width="1"] .weather-condition,
            .widget[data-grid-height="1"] .weather-condition {
                font-size: 1rem;
            }
            
            .widget[data-grid-width="1"] .weather-icon {
                font-size: 1.5rem;
            }

            /* Responsive forecast widget sizing */
            .widget[data-grid-width="2"] .forecast-day-name {
                font-size: 0.9rem;
            }
            
            .widget[data-grid-height="1"] .forecast-icon {
                font-size: 1.5rem;
            }
            
            .widget[data-grid-height="1"] .forecast-temp {
                font-size: 1rem;
            }
        }

        /* Weather Widget */
        .weather-temp {
            font-size: 3rem;
            font-weight: 300;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .weather-temp-unit {
            font-size: 1.5rem;
            opacity: 0.6;
            margin-left: 5px;
        }
        
        .weather-temp-secondary {
            font-size: 1.8rem; /* 60% of 3rem primary temp */
            opacity: 0.5;
            margin-left: 10px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }

        .weather-condition {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .weather-icon {
            font-size: 2.5rem;
            margin: 10px 0;
        }

        .weather-details {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            flex-wrap: wrap;
        }
        
        .weather-location {
            font-size: 1rem;
            opacity: 0.6;
            margin-top: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Forecast Widget */
        .forecast-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 10px;
            /* Use horizontal scroll without wrap for overflow */
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;
        }
        
        .forecast-day {
            text-align: center;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            min-width: 80px; /* Prevent excessive shrinking */
        }
        
        body.theme-light .forecast-day {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .forecast-day-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .forecast-icon {
            font-size: 2rem;
            margin: 8px 0;
        }
        
        .forecast-temp {
            font-size: 1.2rem;
            margin: 5px 0;
        }
        
        .forecast-temp-high {
            font-weight: 600;
        }
        
        .forecast-temp-low {
            opacity: 0.6;
        }
        
        .forecast-precip {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .forecast-temp-secondary {
            font-size: 0.75rem; /* 60-65% of forecast temps */
            opacity: 0.5;
            margin-top: 3px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .forecast-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }
        
        .weather-feels-like-secondary {
            font-size: 0.7rem;
            opacity: 0.5;
            margin-left: 5px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-feels-like-secondary {
            color: #666; /* Darker gray for light theme */
        }

        /* Air Quality Widget */
        .air-quality-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            gap: 8px;
        }

        .air-quality-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .air-quality-aqi {
            font-size: 2.5rem;
            font-weight: 600;
            line-height: 1;
        }

        .air-quality-label {
            font-size: 1rem;
            font-weight: 500;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .air-quality-forecast {
            display: flex;
            gap: 15px;
            margin-top: 8px;
            font-size: 0.85rem;
        }

        .air-quality-day {
            text-align: center;
        }

        .air-quality-day-label {
            opacity: 0.6;
            font-size: 0.75rem;
            margin-bottom: 3px;
        }

        .air-quality-day-value {
            font-weight: 600;
            font-size: 1rem;
        }

        .air-quality-temp {
            margin-top: 5px;
            font-size: 0.8rem;
            opacity: 0.6;
        }

        /* Favorable conditions highlight */
        .widget.air-quality-favorable {
            background: rgba(76, 175, 80, 0.2) !important;
            border: 2px solid rgba(76, 175, 80, 0.6) !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        body.theme-light .widget.air-quality-favorable {
            background: rgba(76, 175, 80, 0.15) !important;
            border: 2px solid rgba(76, 175, 80, 0.8) !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
            }
            50% {
                box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            }
        }

        /* AQI color coding */
        .aqi-good {
            color: #4CAF50;
        }

        .aqi-fair {
            color: #8BC34A;
        }

        .aqi-moderate {
            color: #FFC107;
        }

        .aqi-poor {
            color: #FF9800;
        }

        .aqi-very-poor {
            color: #F44336;
        }

        /* Responsive sizing for compact widget */
        .widget[data-grid-width="1"] .air-quality-aqi {
            font-size: 2rem;
        }

        .widget[data-grid-width="1"] .air-quality-label {
            font-size: 0.8rem;
        }

        .widget[data-grid-width="1"] .air-quality-forecast {
            font-size: 0.7rem;
            gap: 10px;
        }

        .widget[data-grid-height="1"] .air-quality-aqi {
            font-size: 2rem;
        }

        .widget[data-grid-height="1"] .air-quality-label {
            font-size: 0.8rem;
        }

        /* News Widget */
        .news-items {
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            /* Remove max-height: 100% which can cause expansion */
            flex: 1;
            min-height: 0;
            scroll-behavior: smooth;
        }

        .news-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.theme-light .news-item {
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .news-item:last-child {
            border-bottom: none;
        }

        .news-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 5px;
            /* Truncate long titles */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }

        .news-source {
            font-size: 0.8rem;
            opacity: 0.6;
        }

        /* Media Widget */
        .media-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 10px;
        }

        .media-artwork-container {
            flex: 0 0 auto;
            width: 100%;
            max-height: 60%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-radius: 10px;
        }

        .media-artwork {
            width: 100%;
            height: auto;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
        }

        .media-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 5px;
            min-height: 0;
        }

        .media-title {
            font-size: 1.4rem;
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }

        .media-artist {
            font-size: 1.1rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .media-album {
            font-size: 0.9rem;
            opacity: 0.6;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .media-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .media-platform {
            background: rgba(255, 255, 255, 0.15);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        body.theme-light .media-platform {
            background: rgba(0, 0, 0, 0.1);
        }

        .media-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }

        .media-status-icon {
            font-size: 1.1rem;
        }

        .media-idle {
            text-align: center;
            opacity: 0.6;
            padding: 20px;
        }

        .media-idle-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        /* Responsive media widget sizing */
        .widget[data-grid-width="1"] .media-title {
            font-size: 1rem;
            -webkit-line-clamp: 1;
        }

        .widget[data-grid-width="1"] .media-artist {
            font-size: 0.9rem;
        }

        .widget[data-grid-height="1"] .media-artwork-container {
            max-height: 40%;
        }

        .widget[data-grid-width="2"][data-grid-height="2"] .media-artwork-container {
            max-height: 50%;
        }

        /* Error message */
        .error-message {
            color: #ff6b6b;
            padding: 20px;
            text-align: center;
            font-size: 1.2rem;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 20px;
            opacity: 0.6;
        }

        /* Responsive grid positioning - combined position and span rules */
        /* Grid positioning rules are generated dynamically via JavaScript */
        /* based on the configured grid size for each orientation */

        /* Scrollbar styling for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        body.theme-light ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
        }

        body.theme-light ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="dashboard-container" id="dashboardContainer">
        <div class="loading">Loading Smart Mirror Dashboard...</div>
    </div>

    <script>
        let config = null;
        let refreshInterval = null;
        let smartWidgetCycleInterval = null; // Interval for Smart Widget cycling
        let currentOrientation = 'portrait'; // Track current orientation

        // Detect current orientation from URL or screen
        function detectOrientation() {
            // Check URL first
            if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Orientation: landscape (from URL)');
                return 'landscape';
            }
            
            // Try to detect from screen orientation
            try {
                if (window.matchMedia) {
                    // Check if screen is wider than tall (landscape)
                    if (window.matchMedia('(orientation: landscape)').matches) {
                        console.log('[Smart Mirror] Orientation: landscape (from matchMedia)');
                        return 'landscape';
                    } else {
                        console.log('[Smart Mirror] Orientation: portrait (from matchMedia)');
                        return 'portrait';
                    }
                }
            } catch (e) {
                console.warn('[Smart Mirror] matchMedia not available:', e);
            }
            
            // Fallback to comparing dimensions
            if (window.innerWidth > window.innerHeight) {
                console.log('[Smart Mirror] Orientation: landscape (from dimensions)');
                return 'landscape';
            }
            
            console.log('[Smart Mirror] Orientation: portrait (default)');
            return 'portrait';
        }

        // Generate and apply dynamic grid CSS based on configuration
        function applyGridCSS(gridSize) {
            console.log('[Smart Mirror] Applying grid CSS:', gridSize);
            
            const container = document.getElementById('dashboardContainer');
            if (!container) return;
            
            // Set grid template
            container.style.gridTemplateColumns = `repeat(${gridSize.columns}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${gridSize.rows}, 1fr)`;
            
            // Generate dynamic positioning CSS rules
            let styleElement = document.getElementById('dynamic-grid-styles');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'dynamic-grid-styles';
                document.head.appendChild(styleElement);
            }
            
            let cssRules = '';
            
            // Generate column positioning rules
            for (let x = 0; x < gridSize.columns; x++) {
                for (let width = 1; width <= gridSize.columns; width++) {
                    if (x + width <= gridSize.columns) {
                        cssRules += `.widget[data-grid-x="${x}"][data-grid-width="${width}"] { grid-column: ${x + 1} / span ${width}; }\n`;
                    }
                }
            }
            
            // Generate row positioning rules
            for (let y = 0; y < gridSize.rows; y++) {
                for (let height = 1; height <= gridSize.rows; height++) {
                    if (y + height <= gridSize.rows) {
                        cssRules += `.widget[data-grid-y="${y}"][data-grid-height="${height}"] { grid-row: ${y + 1} / span ${height}; }\n`;
                    }
                }
            }
            
            styleElement.textContent = cssRules;
            console.log(`[Smart Mirror] Generated ${cssRules.split('\n').length - 1} CSS positioning rules`);
        }

        // Check and update theme based on current time
        async function checkAndUpdateTheme() {
            try {
                console.log('[Smart Mirror] Checking for theme update...');
                const response = await fetch(`/api/smart-mirror/config?orientation=${currentOrientation}`);
                const data = await response.json();
                
                if (data.success && data.config && data.config.calculatedTheme) {
                    const currentTheme = document.body.classList.contains('theme-light') ? 'light' : 'dark';
                    const newTheme = data.config.calculatedTheme;
                    
                    if (currentTheme !== newTheme) {
                        console.log(`[Smart Mirror] Theme switching from ${currentTheme} to ${newTheme}`);
                        if (newTheme === 'light') {
                            document.body.classList.add('theme-light');
                        } else {
                            document.body.classList.remove('theme-light');
                        }
                    } else {
                        console.log(`[Smart Mirror] Theme unchanged: ${currentTheme}`);
                    }
                    
                    // Update config with new theme info
                    if (config) {
                        config.calculatedTheme = data.config.calculatedTheme;
                        config.themeInfo = data.config.themeInfo;
                    }
                }
            } catch (error) {
                console.error('[Smart Mirror] Error checking theme:', error);
            }
        }

        // Load configuration and initialize dashboard
        async function loadConfig() {
            console.log('[Smart Mirror] Loading configuration from API...');
            console.log('[Smart Mirror] Timestamp:', new Date().toISOString());
            console.log('[Smart Mirror] User Agent:', navigator.userAgent);
            console.log('[Smart Mirror] Page URL:', window.location.href);
            
            // Detect orientation
            currentOrientation = detectOrientation();
            console.log(`[Smart Mirror] Current orientation: ${currentOrientation}`);
            
            try {
                const fetchStart = performance.now();
                console.log(`[Smart Mirror] Fetching config from /api/smart-mirror/config?orientation=${currentOrientation}`);
                
                const response = await fetch(`/api/smart-mirror/config?orientation=${currentOrientation}`);
                const fetchEnd = performance.now();
                
                console.log(`[Smart Mirror] API response received (${Math.round(fetchEnd - fetchStart)}ms)`);
                console.log('[Smart Mirror] Response status:', response.status, response.statusText);
                console.log('[Smart Mirror] Response headers:', {
                    contentType: response.headers.get('content-type'),
                    cacheControl: response.headers.get('cache-control')
                });
                
                const data = await response.json();
                console.log('[Smart Mirror] Config data parsed:', {
                    success: data.success,
                    hasConfig: !!data.config,
                    enabled: data.config?.enabled,
                    theme: data.config?.theme,
                    widgetCount: Object.keys(data.config?.widgets || {}).length
                });
                
                if (data.success && data.config) {
                    config = data.config;
                    console.log('âœ… [Smart Mirror] Config loaded successfully:', config);
                    console.log('[Smart Mirror] Enabled widgets:', 
                        Object.keys(config.widgets || {}).filter(k => config.widgets[k]?.enabled)
                    );
                    
                    // Apply theme - use calculated theme if available, otherwise manual theme
                    const themeToApply = config.calculatedTheme || config.theme || 'dark';
                    console.log('[Smart Mirror] Theme info:', {
                        manualTheme: config.theme,
                        calculatedTheme: config.calculatedTheme,
                        autoMode: config.themeInfo?.autoMode,
                        nextSwitch: config.themeInfo?.nextSwitch,
                        applying: themeToApply
                    });
                    
                    if (themeToApply === 'light') {
                        console.log('[Smart Mirror] Applying light theme');
                        document.body.classList.add('theme-light');
                    } else {
                        console.log('[Smart Mirror] Using dark theme');
                        document.body.classList.remove('theme-light');
                    }
                    
                    // Set up theme checking interval if auto mode is enabled
                    if (config.themeInfo?.autoMode && config.themeInfo?.nextSwitch) {
                        console.log(`[Smart Mirror] Auto theme mode enabled, next switch at: ${config.themeInfo.nextSwitch}`);
                        // Check theme every minute to handle switches
                        setInterval(checkAndUpdateTheme, 60000); // Check every 60 seconds
                    }
                    
                    // Check if dashboard is enabled
                    if (config.enabled === false) {
                        console.warn('âš ï¸  [Smart Mirror] Dashboard is disabled in configuration');
                        showError('Smart Mirror Dashboard is currently disabled. Please enable it in the admin panel.');
                        return;
                    }
                    
                    console.log('[Smart Mirror] Dashboard is enabled, rendering...');
                    
                    // Apply grid CSS based on orientation
                    const gridSize = config.gridSize?.[currentOrientation] || config.gridSize || { columns: 4, rows: 3 };
                    applyGridCSS(gridSize);
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Set up refresh interval
                    if (config.refreshInterval && config.refreshInterval > 0) {
                        console.log(`[Smart Mirror] Setting refresh interval: ${config.refreshInterval}ms`);
                        refreshInterval = setInterval(updateWidgets, config.refreshInterval);
                    }
                } else {
                    console.error('âŒ [Smart Mirror] Config load failed:', data);
                    showError('Failed to load Smart Mirror configuration.');
                }
            } catch (error) {
                console.error('âŒ [Smart Mirror] Error loading config:', error);
                console.error('[Smart Mirror] Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                showError('Error connecting to server. Please check your connection.');
            }
        }

        // Render the dashboard with configured widgets
        function renderDashboard() {
            console.log('[Smart Mirror] Starting dashboard render');
            const container = document.getElementById('dashboardContainer');
            container.innerHTML = '';

            if (!config || !config.widgets) {
                console.error('âŒ [Smart Mirror] No widgets configured');
                showError('No widgets configured.');
                return;
            }

            console.log('[Smart Mirror] Rendering widgets:', Object.keys(config.widgets));
            
            // Get the layout for current orientation
            const layout = config.layouts?.[currentOrientation] || {};
            console.log(`[Smart Mirror] Using ${currentOrientation} layout:`, layout);
            
            // Create array of widgets with their keys for sorting
            const widgetEntries = Object.keys(config.widgets)
                .map(widgetKey => ({
                    key: widgetKey,
                    config: config.widgets[widgetKey],
                    layout: layout[widgetKey] || { x: 0, y: 0, width: 1, height: 1 }
                }))
                .filter(entry => entry.config && entry.config.enabled === true);
            
            // Sort widgets by grid position (y first, then x, then by name as tiebreaker)
            widgetEntries.sort((a, b) => {
                const posA = a.layout || { x: 0, y: 0 };
                const posB = b.layout || { x: 0, y: 0 };
                
                // Sort by y coordinate (row) first
                if (posA.y !== posB.y) {
                    return posA.y - posB.y;
                }
                
                // Then by x coordinate (column)
                if (posA.x !== posB.x) {
                    return posA.x - posB.x;
                }
                
                // If same position, sort alphabetically by widget key for stable ordering
                return a.key.localeCompare(b.key);
            });
            
            console.log('[Smart Mirror] Widget render order:', 
                widgetEntries.map(e => `${e.key}(${e.layout?.x},${e.layout?.y})`).join(', ')
            );
            
            // Create widgets based on sorted configuration
            widgetEntries.forEach(entry => {
                const widgetKey = entry.key;
                const widgetConfig = entry.config;
                const widgetLayout = entry.layout;
                
                console.log(`[Smart Mirror] Processing widget: ${widgetKey}`, {
                    enabled: widgetConfig?.enabled,
                    layout: widgetLayout
                });
                
                const widget = createWidget(widgetKey, widgetConfig, widgetLayout);
                if (widget) {
                    container.appendChild(widget);
                }
            });

            // Start updating dynamic content
            updateWidgets();
        }

        // Create a widget element
        function createWidget(type, widgetConfig, widgetLayout) {
            const widget = document.createElement('div');
            widget.className = 'widget';
            widget.dataset.type = type;
            
            // Set grid position from layout
            const pos = widgetLayout || { x: 0, y: 0, width: 1, height: 1 };
            widget.dataset.gridX = pos.x || 0;
            widget.dataset.gridY = pos.y || 0;
            widget.dataset.gridWidth = pos.width || 1;
            widget.dataset.gridHeight = pos.height || 1;

            // Create widget header
            const header = document.createElement('div');
            header.className = 'widget-header';
            header.textContent = getWidgetTitle(type);
            widget.appendChild(header);

            // Create widget content container
            const content = document.createElement('div');
            content.className = 'widget-content';
            content.id = `widget-${type}`;
            widget.appendChild(content);

            return widget;
        }

        // Get widget title
        function getWidgetTitle(type) {
            const titles = {
                clock: 'ðŸ• Time',
                calendar: 'ðŸ“… Calendar',
                weather: 'ðŸŒ¤ï¸ Weather',
                forecast: 'ðŸŒ¦ï¸ Forecast',
                news: 'ðŸ“° News',
                media: 'ðŸŽµ Now Playing',
                vacation: 'âœˆï¸ Upcoming Vacation',
                airQuality: 'ðŸŒ¬ï¸ Air Quality'
            };
            return titles[type] || type.charAt(0).toUpperCase() + type.slice(1);
        }

        // Update all dynamic widgets
        function updateWidgets() {
            if (!config || !config.widgets) return;

            Object.keys(config.widgets).forEach(widgetKey => {
                const widgetConfig = config.widgets[widgetKey];
                if (widgetConfig && widgetConfig.enabled === true) {
                    updateWidget(widgetKey, widgetConfig);
                }
            });
        }

        // Update individual widget
        function updateWidget(type, widgetConfig) {
            const content = document.getElementById(`widget-${type}`);
            if (!content) return;

            switch (type) {
                case 'clock':
                    updateClockWidget(content, widgetConfig);
                    break;
                case 'calendar':
                    updateCalendarWidget(content, widgetConfig);
                    break;
                case 'weather':
                    updateWeatherWidget(content, widgetConfig);
                    break;
                case 'forecast':
                    updateForecastWidget(content, widgetConfig);
                    break;
                case 'news':
                    updateNewsWidget(content, widgetConfig);
                    break;
                case 'media':
                    updateMediaWidget(content, widgetConfig);
                    break;
                case 'vacation':
                    updateVacationWidget(content, widgetConfig);
                    break;
                case 'airQuality':
                    updateAirQualityWidget(content, widgetConfig);
                    break;
                case 'smartWidget':
                    updateSmartWidget(content, widgetConfig);
                    break;
            }
        }

        // Update clock widget
        function updateClockWidget(content, widgetConfig) {
            const now = new Date();
            
            const timeStr = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });

            const time24Str = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
            
            const dateStr = now.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            let html = `
                <div class="clock-time">${timeStr}</div>
                <div class="clock-time-24h">${time24Str}</div>
                <div class="clock-date">${dateStr}</div>
            `;
            
            // Add additional timezones if configured
            const additionalTimezones = widgetConfig?.additionalTimezones || [];
            if (additionalTimezones.length > 0) {
                additionalTimezones.forEach(tz => {
                    if (tz.city && tz.timezone) {
                        try {
                            const tzTime = now.toLocaleTimeString('en-US', { 
                                timeZone: tz.timezone,
                                hour: '2-digit', 
                                minute: '2-digit',
                                hour12: true 
                            });
                            html += `
                                <div class="clock-additional-timezone">
                                    <div class="clock-additional-city">${tz.city}</div>
                                    <div class="clock-additional-time">${tzTime}</div>
                                </div>
                            `;
                        } catch (error) {
                            console.error(`Invalid timezone: ${tz.timezone}`, error);
                        }
                    }
                });
            }
            
            content.innerHTML = html;
        }

        // Update calendar widget
        // Update calendar widget
        async function updateCalendarWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/calendar');
                const data = await response.json();
                
                // Clear content
                content.innerHTML = '';
                
                // Create calendar container
                const calendarContainer = document.createElement('div');
                calendarContainer.className = 'calendar-container';
                
                // Generate monthly calendar grid
                const monthView = renderMonthlyCalendar(data.events || []);
                calendarContainer.appendChild(monthView);
                
                // Show warnings if there are errors
                if (data.errors && data.errors.length > 0) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'calendar-warning';
                    warningDiv.textContent = 'âš ï¸ Some feeds could not be loaded';
                    calendarContainer.appendChild(warningDiv);
                }
                
                // Render events list
                if (data.success && data.events && data.events.length > 0) {
                    const eventsContainer = document.createElement('div');
                    eventsContainer.className = 'calendar-events';
                    
                    data.events.forEach(event => {
                        const eventDiv = renderEvent(event);
                        eventsContainer.appendChild(eventDiv);
                    });
                    
                    calendarContainer.appendChild(eventsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'calendar-error';
                    errorDiv.textContent = 'âš ï¸ ' + data.error;
                    calendarContainer.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'calendar-error';
                    msgDiv.textContent = 'No upcoming events';
                    calendarContainer.appendChild(msgDiv);
                }
                
                content.appendChild(calendarContainer);
            } catch (error) {
                console.error('Error fetching calendar:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'calendar-error';
                errorDiv.textContent = 'Error loading calendar';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Render monthly calendar grid
        function renderMonthlyCalendar(events) {
            const monthView = document.createElement('div');
            monthView.className = 'calendar-month-view';
            
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            
            // Create header with month/year
            const header = document.createElement('div');
            header.className = 'calendar-header';
            header.textContent = now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            monthView.appendChild(header);
            
            // Create calendar grid
            const grid = document.createElement('div');
            grid.className = 'calendar-grid';
            
            // Day names
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(day => {
                const dayNameDiv = document.createElement('div');
                dayNameDiv.className = 'calendar-day-name';
                dayNameDiv.textContent = day;
                grid.appendChild(dayNameDiv);
            });
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Create a map of dates with events
            const eventDates = new Set();
            events.forEach(event => {
                const eventDate = new Date(event.start);
                if (eventDate.getMonth() === month && eventDate.getFullYear() === year) {
                    eventDates.add(eventDate.getDate());
                }
            });
            
            // Previous month days
            for (let i = firstDay - 1; i >= 0; i--) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = daysInPrevMonth - i;
                grid.appendChild(dayDiv);
            }
            
            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                dayDiv.textContent = day;
                
                // Highlight today
                if (day === now.getDate()) {
                    dayDiv.classList.add('today');
                }
                
                // Mark days with events
                if (eventDates.has(day)) {
                    dayDiv.classList.add('has-event');
                }
                
                grid.appendChild(dayDiv);
            }
            
            // Next month days to fill grid
            const totalCells = grid.children.length - 7; // Subtract day names
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let day = 1; day <= remainingCells; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = day;
                grid.appendChild(dayDiv);
            }
            
            monthView.appendChild(grid);
            return monthView;
        }
        
        // Render individual event
        function renderEvent(event) {
            const eventDiv = document.createElement('div');
            eventDiv.className = 'calendar-event';
            
            // Add all-day class if applicable
            if (event.isAllDay) {
                eventDiv.classList.add('all-day');
            }
            
            const startDate = new Date(event.start);
            
            // Main info div
            const mainDiv = document.createElement('div');
            
            // Time/date display
            const timeSpan = document.createElement('span');
            timeSpan.className = 'calendar-event-time';
            
            if (event.isAllDay) {
                // For all-day events, show date only
                timeSpan.textContent = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    weekday: 'short'
                });
            } else {
                // For timed events, show date and time
                const dateStr = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric' 
                });
                const timeStr = startDate.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                timeSpan.textContent = `${dateStr} ${timeStr}`;
            }
            mainDiv.appendChild(timeSpan);
            
            // Title
            const titleSpan = document.createElement('span');
            titleSpan.className = 'calendar-event-title';
            titleSpan.textContent = event.title || 'Untitled Event';
            mainDiv.appendChild(titleSpan);
            
            eventDiv.appendChild(mainDiv);
            
            // Location
            if (event.location) {
                const locationDiv = document.createElement('div');
                locationDiv.className = 'calendar-event-location';
                locationDiv.textContent = 'ðŸ“ ' + event.location;
                eventDiv.appendChild(locationDiv);
            }
            
            // Description (truncated)
            if (event.description && event.description.trim()) {
                const descDiv = document.createElement('div');
                descDiv.className = 'calendar-event-description';
                // Remove excessive whitespace and limit length
                const cleanDesc = event.description.replace(/\s+/g, ' ').trim();
                descDiv.textContent = cleanDesc.length > 100 ? cleanDesc.substring(0, 100) + '...' : cleanDesc;
                eventDiv.appendChild(descDiv);
            }
            
            return eventDiv;
        }


        // Helper function to convert Celsius to Fahrenheit
        function celsiusToFahrenheit(celsius) {
            return Math.round((celsius * 9/5) + 32);
        }

        // Helper function to convert Fahrenheit to Celsius
        function fahrenheitToCelsius(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5/9);
        }

        // Helper function to get weather icon from OpenWeatherMap icon code
        function getWeatherIcon(iconCode) {
            const iconMap = {
                '01d': 'â˜€ï¸', '01n': 'ðŸŒ™',
                '02d': 'â›…', '02n': 'â˜ï¸',
                '03d': 'â˜ï¸', '03n': 'â˜ï¸',
                '04d': 'â˜ï¸', '04n': 'â˜ï¸',
                '09d': 'ðŸŒ§ï¸', '09n': 'ðŸŒ§ï¸',
                '10d': 'ðŸŒ¦ï¸', '10n': 'ðŸŒ§ï¸',
                '11d': 'â›ˆï¸', '11n': 'â›ˆï¸',
                '13d': 'ðŸŒ¨ï¸', '13n': 'ðŸŒ¨ï¸',
                '50d': 'ðŸŒ«ï¸', '50n': 'ðŸŒ«ï¸'
            };
            return iconMap[iconCode] || 'ðŸŒ¤ï¸';
        }

        // Update weather widget
        async function updateWeatherWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/weather');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const weather = data.data;
                    const isImperial = weather.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    const tempSecondary = isImperial ? fahrenheitToCelsius(weather.temp) : celsiusToFahrenheit(weather.temp);
                    const secondaryUnit = isImperial ? 'C' : 'F';
                    const windUnit = isImperial ? 'mph' : 'm/s';
                    
                    // Create elements safely
                    content.innerHTML = '';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'weather-icon';
                    iconDiv.textContent = getWeatherIcon(weather.icon);
                    content.appendChild(iconDiv);
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.className = 'weather-temp';
                    tempDiv.textContent = weather.temp + 'Â°';
                    
                    const tempUnitSpan = document.createElement('span');
                    tempUnitSpan.className = 'weather-temp-unit';
                    tempUnitSpan.textContent = tempUnit;
                    tempDiv.appendChild(tempUnitSpan);
                    
                    const tempSecondarySpan = document.createElement('span');
                    tempSecondarySpan.className = 'weather-temp-secondary';
                    tempSecondarySpan.textContent = tempSecondary + 'Â°' + secondaryUnit;
                    tempDiv.appendChild(tempSecondarySpan);
                    content.appendChild(tempDiv);
                    
                    const conditionDiv = document.createElement('div');
                    conditionDiv.className = 'weather-condition';
                    conditionDiv.textContent = weather.description || 'Unknown';
                    content.appendChild(conditionDiv);
                    
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'weather-location';
                    locationDiv.textContent = weather.location + (weather.country ? ', ' + weather.country : '');
                    content.appendChild(locationDiv);
                    
                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'weather-details';
                    
                    const humidityDiv = document.createElement('div');
                    humidityDiv.textContent = 'ðŸ’§ ' + weather.humidity + '%';
                    detailsDiv.appendChild(humidityDiv);
                    
                    const windDiv = document.createElement('div');
                    windDiv.textContent = 'ðŸ’¨ ' + weather.windSpeed + ' ' + windUnit;
                    detailsDiv.appendChild(windDiv);
                    
                    if (weather.feelsLike) {
                        const feelsLikeSecondary = isImperial ? fahrenheitToCelsius(weather.feelsLike) : celsiusToFahrenheit(weather.feelsLike);
                        const feelsLikeDiv = document.createElement('div');
                        feelsLikeDiv.textContent = 'Feels: ' + weather.feelsLike + 'Â°' + tempUnit;
                        
                        const feelsLikeSecondarySpan = document.createElement('span');
                        feelsLikeSecondarySpan.className = 'weather-feels-like-secondary';
                        feelsLikeSecondarySpan.textContent = ' (' + feelsLikeSecondary + 'Â°' + secondaryUnit + ')';
                        feelsLikeDiv.appendChild(feelsLikeSecondarySpan);
                        
                        detailsDiv.appendChild(feelsLikeDiv);
                    }
                    
                    content.appendChild(detailsDiv);
                } else if (data.error) {
                    const errorContainer = document.createElement('div');
                    errorContainer.style.opacity = '0.6';
                    errorContainer.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = 'âš ï¸';
                    errorContainer.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorContainer.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorContainer);
                }
            } catch (error) {
                console.error('Error fetching weather:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading weather';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update forecast widget
        async function updateForecastWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/forecast');
                const data = await response.json();
                
                if (data.success && data.days && data.days.length > 0) {
                    const isImperial = data.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    
                    let forecastHTML = '<div class="forecast-container">';
                    data.days.forEach(day => {
                        const tempHigh = day.tempHigh;
                        const tempLow = day.tempLow;
                        const tempHighSecondary = isImperial ? fahrenheitToCelsius(tempHigh) : celsiusToFahrenheit(tempHigh);
                        const tempLowSecondary = isImperial ? fahrenheitToCelsius(tempLow) : celsiusToFahrenheit(tempLow);
                        const secondaryUnit = isImperial ? 'C' : 'F';
                        
                        forecastHTML += `
                            <div class="forecast-day">
                                <div class="forecast-day-name">${day.dayName}</div>
                                <div class="forecast-icon">${getWeatherIcon(day.icon)}</div>
                                <div class="forecast-temp">
                                    <div class="forecast-temp-high">${tempHigh}Â°${tempUnit}</div>
                                    <div class="forecast-temp-low">${tempLow}Â°${tempUnit}</div>
                                    <div class="forecast-temp-secondary">
                                        ${tempHighSecondary}Â°/${tempLowSecondary}Â°${secondaryUnit}
                                    </div>
                                </div>
                                ${day.precipChance > 0 ? `<div class="forecast-precip">ðŸ’§ ${day.precipChance}%</div>` : ''}
                            </div>
                        `;
                    });
                    forecastHTML += '</div>';
                    content.innerHTML = forecastHTML;
                } else if (data.error) {
                    content.innerHTML = `<div style="opacity: 0.6; text-align: center;">âš ï¸ ${data.error}</div>`;
                }
            } catch (error) {
                console.error('Error fetching forecast:', error);
                content.innerHTML = '<div style="opacity: 0.6; text-align: center;">Error loading forecast</div>';
            }
        }

        // Update news widget
        async function updateNewsWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/news');
                const data = await response.json();
                
                if (data.success && data.items && data.items.length > 0) {
                    content.innerHTML = '';
                    const newsContainer = document.createElement('div');
                    newsContainer.className = 'news-items';
                    
                    data.items.slice(0, 5).forEach(item => {
                        const date = item.pubDate ? new Date(item.pubDate).toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric' 
                        }) : '';
                        
                        const newsItem = document.createElement('div');
                        newsItem.className = 'news-item';
                        
                        const title = document.createElement('div');
                        title.className = 'news-title';
                        title.textContent = item.title || 'Untitled';
                        newsItem.appendChild(title);
                        
                        const source = document.createElement('div');
                        source.className = 'news-source';
                        source.textContent = item.source + (date ? ' â€¢ ' + date : '');
                        newsItem.appendChild(source);
                        
                        newsContainer.appendChild(newsItem);
                    });
                    
                    content.appendChild(newsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.opacity = '0.6';
                    errorDiv.style.textAlign = 'center';
                    errorDiv.textContent = 'âš ï¸ ' + data.error;
                    content.innerHTML = '';
                    content.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.opacity = '0.6';
                    msgDiv.style.textAlign = 'center';
                    msgDiv.textContent = 'No news items available';
                    content.innerHTML = '';
                    content.appendChild(msgDiv);
                }
            } catch (error) {
                console.error('Error fetching news:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading news';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update media widget
        async function updateMediaWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/media');
                const data = await response.json();
                
                if (data.success && data.state && data.state !== 'idle') {
                    content.innerHTML = '';
                    const mediaContainer = document.createElement('div');
                    mediaContainer.className = 'media-container';
                    
                    // Artwork
                    if (data.artworkUrl) {
                        const artworkContainer = document.createElement('div');
                        artworkContainer.className = 'media-artwork-container';
                        
                        const artwork = document.createElement('img');
                        artwork.className = 'media-artwork';
                        artwork.src = data.artworkUrl;
                        artwork.alt = 'Album Artwork';
                        artwork.onerror = () => {
                            artworkContainer.style.display = 'none';
                        };
                        artworkContainer.appendChild(artwork);
                        mediaContainer.appendChild(artworkContainer);
                    }
                    
                    // Media info
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'media-info';
                    
                    if (data.title) {
                        const titleDiv = document.createElement('div');
                        titleDiv.className = 'media-title';
                        titleDiv.textContent = data.title;
                        infoDiv.appendChild(titleDiv);
                    }
                    
                    if (data.artist) {
                        const artistDiv = document.createElement('div');
                        artistDiv.className = 'media-artist';
                        artistDiv.textContent = data.artist;
                        infoDiv.appendChild(artistDiv);
                    }
                    
                    if (data.album) {
                        const albumDiv = document.createElement('div');
                        albumDiv.className = 'media-album';
                        albumDiv.textContent = data.album;
                        infoDiv.appendChild(albumDiv);
                    }
                    
                    // Footer with platform and status
                    const footerDiv = document.createElement('div');
                    footerDiv.className = 'media-footer';
                    
                    const platformDiv = document.createElement('div');
                    platformDiv.className = 'media-platform';
                    platformDiv.textContent = data.platform || 'Media Player';
                    footerDiv.appendChild(platformDiv);
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'media-status';
                    
                    const statusIcon = document.createElement('span');
                    statusIcon.className = 'media-status-icon';
                    
                    if (data.state === 'playing') {
                        statusIcon.textContent = 'â–¶ï¸';
                        statusDiv.appendChild(statusIcon);
                        const statusText = document.createElement('span');
                        statusText.textContent = 'Playing';
                        statusDiv.appendChild(statusText);
                    } else if (data.state === 'paused') {
                        statusIcon.textContent = 'â¸ï¸';
                        statusDiv.appendChild(statusIcon);
                        const statusText = document.createElement('span');
                        statusText.textContent = 'Paused';
                        statusDiv.appendChild(statusText);
                    } else {
                        statusDiv.textContent = data.state.charAt(0).toUpperCase() + data.state.slice(1);
                    }
                    
                    footerDiv.appendChild(statusDiv);
                    infoDiv.appendChild(footerDiv);
                    
                    mediaContainer.appendChild(infoDiv);
                    content.appendChild(mediaContainer);
                } else if (data.state === 'idle' || data.message) {
                    // Show idle state
                    content.innerHTML = '';
                    const idleDiv = document.createElement('div');
                    idleDiv.className = 'media-idle';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'media-idle-icon';
                    iconDiv.textContent = 'ðŸŽµ';
                    idleDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.message || 'No media playing';
                    idleDiv.appendChild(msgDiv);
                    
                    content.appendChild(idleDiv);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.opacity = '0.6';
                    errorDiv.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = 'âš ï¸';
                    errorDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorDiv.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorDiv);
                }
            } catch (error) {
                console.error('Error fetching media:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading media player';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update vacation widget
        async function updateVacationWidget(content, widgetConfig) {
            // Timezone conversion constants
            const SECONDS_PER_MINUTE = 60;
            const SECONDS_PER_HOUR = 3600;
            const MILLISECONDS_PER_HOUR = 3600000;
            const MIN_TIMEZONE_DIFF_HOURS = 1;
            
            try {
                // Fetch vacation data
                const vacationResponse = await fetch('/api/smart-mirror/vacation');
                const vacationData = await vacationResponse.json();
                
                if (!vacationData.success) {
                    throw new Error(vacationData.error || 'Failed to fetch vacation data');
                }
                
                const vacations = vacationData.vacations || [];
                
                if (vacations.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.style.opacity = '0.6';
                    emptyDiv.style.textAlign = 'center';
                    emptyDiv.style.padding = '20px 0';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = 'âœˆï¸';
                    emptyDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = 'No upcoming vacations';
                    emptyDiv.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(emptyDiv);
                    return;
                }
                
                content.innerHTML = '';
                
                // Display up to 3 upcoming vacations
                const displayVacations = vacations.slice(0, 3);
                
                for (const vacation of displayVacations) {
                    const vacationDiv = document.createElement('div');
                    vacationDiv.className = 'vacation-item';
                    vacationDiv.style.marginBottom = '20px';
                    vacationDiv.style.paddingBottom = '15px';
                    vacationDiv.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
                    
                    // Destination header
                    const headerDiv = document.createElement('div');
                    headerDiv.style.display = 'flex';
                    headerDiv.style.alignItems = 'center';
                    headerDiv.style.marginBottom = '8px';
                    
                    const iconSpan = document.createElement('span');
                    iconSpan.style.fontSize = '1.2rem';
                    iconSpan.style.marginRight = '8px';
                    iconSpan.textContent = 'ðŸ“';
                    headerDiv.appendChild(iconSpan);
                    
                    const destDiv = document.createElement('div');
                    destDiv.style.fontSize = '1.1rem';
                    destDiv.style.fontWeight = 'bold';
                    destDiv.textContent = vacation.destination || 'Vacation';
                    headerDiv.appendChild(destDiv);
                    
                    vacationDiv.appendChild(headerDiv);
                    
                    // Dates and countdown
                    const startDate = new Date(vacation.startDate);
                    const endDate = new Date(vacation.endDate);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    const daysUntil = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                    
                    const dateDiv = document.createElement('div');
                    dateDiv.style.fontSize = '0.9rem';
                    dateDiv.style.marginBottom = '5px';
                    dateDiv.textContent = formatDateRange(startDate, endDate);
                    vacationDiv.appendChild(dateDiv);
                    
                    if (daysUntil > 0) {
                        const countdownDiv = document.createElement('div');
                        countdownDiv.style.fontSize = '0.85rem';
                        countdownDiv.style.opacity = '0.8';
                        countdownDiv.style.marginBottom = '8px';
                        countdownDiv.textContent = `ðŸ—“ï¸ ${daysUntil} ${daysUntil === 1 ? 'day' : 'days'} away`;
                        vacationDiv.appendChild(countdownDiv);
                    } else if (daysUntil === 0) {
                        const countdownDiv = document.createElement('div');
                        countdownDiv.style.fontSize = '0.85rem';
                        countdownDiv.style.color = '#4ade80';
                        countdownDiv.style.marginBottom = '8px';
                        countdownDiv.textContent = 'ðŸŽ‰ Today!';
                        vacationDiv.appendChild(countdownDiv);
                    }
                    
                    // Fetch weather and timezone if destination is provided
                    if (vacation.destination && vacation.destination.trim()) {
                        try {
                            // Fetch timezone info
                            const timezoneResponse = await fetch(`/api/smart-mirror/vacation-timezone?location=${encodeURIComponent(vacation.destination)}`);
                            const timezoneData = await timezoneResponse.json();
                            
                            // Display local time if timezone differs from browser timezone
                            if (timezoneData.success && timezoneData.data) {
                                const localOffset = new Date().getTimezoneOffset() * -SECONDS_PER_MINUTE; // Browser offset in seconds
                                const destOffset = timezoneData.data.timezoneOffset;
                                const offsetDiff = (destOffset - localOffset) / SECONDS_PER_HOUR; // Difference in hours
                                
                                if (Math.abs(offsetDiff) >= MIN_TIMEZONE_DIFF_HOURS) {
                                    // Calculate destination time
                                    const now = new Date();
                                    const destTime = new Date(now.getTime() + offsetDiff * MILLISECONDS_PER_HOUR);
                                    
                                    const timeDiv = document.createElement('div');
                                    timeDiv.style.fontSize = '0.85rem';
                                    timeDiv.style.marginBottom = '8px';
                                    timeDiv.style.display = 'flex';
                                    timeDiv.style.alignItems = 'center';
                                    
                                    const clockIcon = document.createElement('span');
                                    clockIcon.textContent = 'ðŸ• ';
                                    clockIcon.style.marginRight = '4px';
                                    timeDiv.appendChild(clockIcon);
                                    
                                    const timeText = document.createElement('span');
                                    timeText.textContent = `Local: ${destTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })} `;
                                    timeDiv.appendChild(timeText);
                                    
                                    const offsetText = document.createElement('span');
                                    offsetText.style.opacity = '0.7';
                                    offsetText.textContent = `(${offsetDiff >= 0 ? '+' : ''}${offsetDiff.toFixed(0)}h)`;
                                    timeDiv.appendChild(offsetText);
                                    
                                    vacationDiv.appendChild(timeDiv);
                                }
                            }
                            
                            // Fetch weather forecast
                            const weatherResponse = await fetch(`/api/smart-mirror/vacation-weather?location=${encodeURIComponent(vacation.destination)}`);
                            const weatherData = await weatherResponse.json();
                            
                            if (weatherData.success && weatherData.days && weatherData.days.length > 0) {
                                const weatherDiv = document.createElement('div');
                                weatherDiv.style.fontSize = '0.85rem';
                                weatherDiv.style.marginTop = '8px';
                                
                                // Find weather for vacation dates
                                const vacationDays = weatherData.days.filter(day => {
                                    const dayDate = new Date(day.date);
                                    return dayDate >= startDate && dayDate <= endDate;
                                });
                                
                                if (vacationDays.length > 0) {
                                    // Show average or first day weather
                                    const firstDay = vacationDays[0];
                                    const weatherIcon = getWeatherIcon(firstDay.icon);
                                    
                                    const weatherContent = document.createElement('div');
                                    weatherContent.style.display = 'flex';
                                    weatherContent.style.alignItems = 'center';
                                    weatherContent.style.gap = '8px';
                                    
                                    const iconSpan = document.createElement('span');
                                    iconSpan.style.fontSize = '1.3rem';
                                    iconSpan.textContent = weatherIcon;
                                    weatherContent.appendChild(iconSpan);
                                    
                                    const tempSpan = document.createElement('span');
                                    tempSpan.textContent = `${firstDay.tempHigh}Â° / ${firstDay.tempLow}Â°`;
                                    weatherContent.appendChild(tempSpan);
                                    
                                    const condSpan = document.createElement('span');
                                    condSpan.style.opacity = '0.8';
                                    condSpan.textContent = firstDay.condition || firstDay.description;
                                    weatherContent.appendChild(condSpan);
                                    
                                    weatherDiv.appendChild(weatherContent);
                                } else if (weatherData.isFallback && weatherData.days && weatherData.days.length > 0) {
                                    // Show current weather as fallback
                                    const day = weatherData.days[0];
                                    const weatherIcon = getWeatherIcon(day.icon);
                                    
                                    const weatherContent = document.createElement('div');
                                    weatherContent.style.display = 'flex';
                                    weatherContent.style.alignItems = 'center';
                                    weatherContent.style.gap = '8px';
                                    
                                    const iconSpan = document.createElement('span');
                                    iconSpan.style.fontSize = '1.3rem';
                                    iconSpan.textContent = weatherIcon;
                                    weatherContent.appendChild(iconSpan);
                                    
                                    const tempSpan = document.createElement('span');
                                    tempSpan.textContent = `${day.tempHigh}Â°`;
                                    weatherContent.appendChild(tempSpan);
                                    
                                    const condSpan = document.createElement('span');
                                    condSpan.style.opacity = '0.8';
                                    condSpan.textContent = day.condition || day.description;
                                    weatherContent.appendChild(condSpan);
                                    
                                    weatherDiv.appendChild(weatherContent);
                                    
                                    const fallbackNote = document.createElement('div');
                                    fallbackNote.style.fontSize = '0.75rem';
                                    fallbackNote.style.opacity = '0.6';
                                    fallbackNote.style.marginTop = '4px';
                                    fallbackNote.textContent = '(Current weather - forecast unavailable)';
                                    weatherDiv.appendChild(fallbackNote);
                                } else {
                                    const noWeatherSpan = document.createElement('span');
                                    noWeatherSpan.style.opacity = '0.6';
                                    noWeatherSpan.textContent = 'â›… Weather forecast not available for dates';
                                    weatherDiv.appendChild(noWeatherSpan);
                                }
                                
                                vacationDiv.appendChild(weatherDiv);
                            }
                        } catch (weatherError) {
                            console.error('Error fetching vacation weather/timezone:', weatherError);
                            // Silently fail for weather - don't show error to user
                        }
                    }
                    
                    // Display flight information if tracking is enabled
                    if (vacation.flightTrackingEnabled && vacation.flights && vacation.flights.length > 0) {
                        try {
                            const flightDiv = document.createElement('div');
                            flightDiv.style.marginTop = '12px';
                            flightDiv.style.padding = '8px';
                            flightDiv.style.background = 'rgba(255, 255, 255, 0.05)';
                            flightDiv.style.borderRadius = '5px';
                            flightDiv.style.fontSize = '0.85rem';
                            
                            // Fetch flight status for each validated flight
                            for (const flight of vacation.flights) {
                                if (!flight.validated) continue; // Only show validated flights
                                
                                const flightItemDiv = document.createElement('div');
                                flightItemDiv.style.marginBottom = '8px';
                                flightItemDiv.style.paddingBottom = '8px';
                                if (vacation.flights.indexOf(flight) < vacation.flights.length - 1) {
                                    flightItemDiv.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
                                }
                                
                                try {
                                    const statusResponse = await fetch(
                                        `/api/smart-mirror/flight-status?flightNumber=${encodeURIComponent(flight.flightNumber)}&airline=${encodeURIComponent(flight.airline)}&date=${encodeURIComponent(flight.date)}`
                                    );
                                    const statusData = await statusResponse.json();
                                    
                                    if (statusData.success && statusData.data) {
                                        const flightStatus = statusData.data;
                                        
                                        // Flight header
                                        const headerDiv = document.createElement('div');
                                        headerDiv.style.display = 'flex';
                                        headerDiv.style.alignItems = 'center';
                                        headerDiv.style.gap = '6px';
                                        headerDiv.style.marginBottom = '4px';
                                        
                                        const iconSpan = document.createElement('span');
                                        iconSpan.textContent = 'âœˆï¸';
                                        headerDiv.appendChild(iconSpan);
                                        
                                        const flightNumSpan = document.createElement('span');
                                        flightNumSpan.style.fontWeight = 'bold';
                                        flightNumSpan.textContent = flightStatus.flightNumber;
                                        headerDiv.appendChild(flightNumSpan);
                                        
                                        // Status badge
                                        const statusSpan = document.createElement('span');
                                        statusSpan.style.padding = '2px 6px';
                                        statusSpan.style.borderRadius = '3px';
                                        statusSpan.style.fontSize = '0.75rem';
                                        statusSpan.style.fontWeight = 'bold';
                                        
                                        if (flightStatus.status === 'On Time') {
                                            statusSpan.style.background = '#10b981';
                                            statusSpan.style.color = '#fff';
                                        } else if (flightStatus.status === 'Delayed') {
                                            statusSpan.style.background = '#ef4444';
                                            statusSpan.style.color = '#fff';
                                        } else if (flightStatus.status === 'Completed') {
                                            statusSpan.style.background = '#6b7280';
                                            statusSpan.style.color = '#fff';
                                        } else {
                                            statusSpan.style.background = '#3b82f6';
                                            statusSpan.style.color = '#fff';
                                        }
                                        statusSpan.textContent = flightStatus.status;
                                        headerDiv.appendChild(statusSpan);
                                        
                                        flightItemDiv.appendChild(headerDiv);
                                        
                                        // Flight details
                                        if (flightStatus.gate || flightStatus.terminal) {
                                            const detailsDiv = document.createElement('div');
                                            detailsDiv.style.opacity = '0.8';
                                            detailsDiv.style.fontSize = '0.8rem';
                                            detailsDiv.style.marginLeft = '20px';
                                            
                                            const details = [];
                                            if (flightStatus.terminal) details.push(`Terminal ${flightStatus.terminal}`);
                                            if (flightStatus.gate) details.push(`Gate ${flightStatus.gate}`);
                                            
                                            detailsDiv.textContent = details.join(' â€¢ ');
                                            flightItemDiv.appendChild(detailsDiv);
                                        }
                                    } else {
                                        // Show basic flight info without status
                                        const headerDiv = document.createElement('div');
                                        headerDiv.style.display = 'flex';
                                        headerDiv.style.alignItems = 'center';
                                        headerDiv.style.gap = '6px';
                                        headerDiv.style.opacity = '0.7';
                                        
                                        const iconSpan = document.createElement('span');
                                        iconSpan.textContent = 'âœˆï¸';
                                        headerDiv.appendChild(iconSpan);
                                        
                                        const flightNumSpan = document.createElement('span');
                                        flightNumSpan.textContent = `${flight.flightNumber} - Status unavailable`;
                                        headerDiv.appendChild(flightNumSpan);
                                        
                                        flightItemDiv.appendChild(headerDiv);
                                    }
                                } catch (flightError) {
                                    console.error(`Error fetching flight status for ${flight.flightNumber}:`, flightError);
                                    // Show basic flight info on error
                                    const headerDiv = document.createElement('div');
                                    headerDiv.style.display = 'flex';
                                    headerDiv.style.alignItems = 'center';
                                    headerDiv.style.gap = '6px';
                                    headerDiv.style.opacity = '0.7';
                                    
                                    const iconSpan = document.createElement('span');
                                    iconSpan.textContent = 'âœˆï¸';
                                    headerDiv.appendChild(iconSpan);
                                    
                                    const flightNumSpan = document.createElement('span');
                                    flightNumSpan.textContent = `${flight.flightNumber} - Error loading status`;
                                    headerDiv.appendChild(flightNumSpan);
                                    
                                    flightItemDiv.appendChild(headerDiv);
                                }
                                
                                flightDiv.appendChild(flightItemDiv);
                            }
                            
                            vacationDiv.appendChild(flightDiv);
                        } catch (error) {
                            console.error('Error displaying flight information:', error);
                            // Silently fail - don't show error to user
                        }
                    }
                    
                    // Add notes if available
                    if (vacation.notes && vacation.notes.trim()) {
                        const notesDiv = document.createElement('div');
                        notesDiv.style.fontSize = '0.8rem';
                        notesDiv.style.opacity = '0.7';
                        notesDiv.style.marginTop = '8px';
                        notesDiv.style.fontStyle = 'italic';
                        notesDiv.textContent = vacation.notes;
                        vacationDiv.appendChild(notesDiv);
                    }
                    
                    content.appendChild(vacationDiv);
                }
                
            } catch (error) {
                console.error('Error fetching vacation data:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                
                const iconDiv = document.createElement('div');
                iconDiv.style.fontSize = '2rem';
                iconDiv.style.marginBottom = '10px';
                iconDiv.textContent = 'âš ï¸';
                errorDiv.appendChild(iconDiv);
                
                const msgDiv = document.createElement('div');
                msgDiv.textContent = error.message || 'Error loading vacation data';
                errorDiv.appendChild(msgDiv);
                
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Update air quality widget
        async function updateAirQualityWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/air-quality');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const aq = data.data;
                    
                    // Clear content
                    content.innerHTML = '';
                    
                    // Create container
                    const container = document.createElement('div');
                    container.className = 'air-quality-container';
                    
                    // Get AQI color class
                    const getAqiClass = (aqi) => {
                        const classes = {
                            1: 'aqi-good',
                            2: 'aqi-fair',
                            3: 'aqi-moderate',
                            4: 'aqi-poor',
                            5: 'aqi-very-poor'
                        };
                        return classes[aqi] || '';
                    };
                    
                    // Get AQI icon
                    const getAqiIcon = (aqi) => {
                        const icons = {
                            1: 'ðŸ˜Š',
                            2: 'ðŸ™‚',
                            3: 'ðŸ˜',
                            4: 'ðŸ˜·',
                            5: 'ðŸ¤¢'
                        };
                        return icons[aqi] || 'ðŸŒ¬ï¸';
                    };
                    
                    // Icon
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'air-quality-icon';
                    iconDiv.textContent = getAqiIcon(aq.current.aqi);
                    container.appendChild(iconDiv);
                    
                    // Current AQI
                    const aqiDiv = document.createElement('div');
                    aqiDiv.className = `air-quality-aqi ${getAqiClass(aq.current.aqi)}`;
                    aqiDiv.textContent = aq.current.aqi;
                    container.appendChild(aqiDiv);
                    
                    // Label
                    const labelDiv = document.createElement('div');
                    labelDiv.className = `air-quality-label ${getAqiClass(aq.current.aqi)}`;
                    labelDiv.textContent = aq.current.label;
                    container.appendChild(labelDiv);
                    
                    // Forecast (Today and Tomorrow)
                    const forecastDiv = document.createElement('div');
                    forecastDiv.className = 'air-quality-forecast';
                    
                    // Today
                    const todayDiv = document.createElement('div');
                    todayDiv.className = 'air-quality-day';
                    
                    const todayLabelDiv = document.createElement('div');
                    todayLabelDiv.className = 'air-quality-day-label';
                    todayLabelDiv.textContent = 'Today';
                    todayDiv.appendChild(todayLabelDiv);
                    
                    const todayValueDiv = document.createElement('div');
                    todayValueDiv.className = `air-quality-day-value ${getAqiClass(aq.today.aqi)}`;
                    todayValueDiv.textContent = aq.today.label;
                    todayDiv.appendChild(todayValueDiv);
                    
                    forecastDiv.appendChild(todayDiv);
                    
                    // Tomorrow
                    if (aq.tomorrow) {
                        const tomorrowDiv = document.createElement('div');
                        tomorrowDiv.className = 'air-quality-day';
                        
                        const tomorrowLabelDiv = document.createElement('div');
                        tomorrowLabelDiv.className = 'air-quality-day-label';
                        tomorrowLabelDiv.textContent = 'Tomorrow';
                        tomorrowDiv.appendChild(tomorrowLabelDiv);
                        
                        const tomorrowValueDiv = document.createElement('div');
                        tomorrowValueDiv.className = `air-quality-day-value ${getAqiClass(aq.tomorrow.aqi)}`;
                        tomorrowValueDiv.textContent = aq.tomorrow.label;
                        tomorrowDiv.appendChild(tomorrowValueDiv);
                        
                        forecastDiv.appendChild(tomorrowDiv);
                    }
                    
                    container.appendChild(forecastDiv);
                    
                    // Temperature info
                    const tempDiv = document.createElement('div');
                    tempDiv.className = 'air-quality-temp';
                    const tempUnit = aq.units === 'imperial' ? 'F' : 'C';
                    tempDiv.textContent = `Current: ${aq.currentTemp}Â°${tempUnit}`;
                    container.appendChild(tempDiv);
                    
                    content.appendChild(container);
                    
                    // Apply favorable conditions highlight if enabled
                    if (aq.highlightEnabled && aq.isFavorable) {
                        const widget = content.closest('.widget');
                        if (widget) {
                            widget.classList.add('air-quality-favorable');
                        }
                    } else {
                        // Remove highlight if not favorable
                        const widget = content.closest('.widget');
                        if (widget) {
                            widget.classList.remove('air-quality-favorable');
                        }
                    }
                    
                } else if (data.error) {
                    const errorContainer = document.createElement('div');
                    errorContainer.style.opacity = '0.6';
                    errorContainer.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = 'âš ï¸';
                    errorContainer.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorContainer.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorContainer);
                }
            } catch (error) {
                console.error('Error fetching air quality:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading air quality';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Smart Widget - Container for multiple sub-widgets
        async function updateSmartWidget(content, widgetConfig) {
            try {
                // Fetch aggregated sub-widget data
                const response = await fetch('/api/smart-mirror/smart-widget');
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch Smart Widget data');
                }
                
                // Clear previous content
                content.innerHTML = '';
                
                const subWidgets = data.subWidgets || [];
                
                if (subWidgets.length === 0) {
                    // No active sub-widgets
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'smart-widget-empty';
                    emptyDiv.style.opacity = '0.6';
                    emptyDiv.style.textAlign = 'center';
                    emptyDiv.style.padding = '20px 0';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = 'ðŸ“±';
                    emptyDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = 'No active notifications';
                    emptyDiv.appendChild(msgDiv);
                    
                    content.appendChild(emptyDiv);
                    
                    // Clear cycling interval if no widgets
                    if (smartWidgetCycleInterval) {
                        clearInterval(smartWidgetCycleInterval);
                        smartWidgetCycleInterval = null;
                    }
                    return;
                }
                
                // Create container based on display mode
                const displayMode = data.displayMode || 'cycle';
                const simultaneousMax = data.simultaneousMax || 2;
                
                if (displayMode === 'simultaneous') {
                    // Show multiple sub-widgets at once
                    const container = document.createElement('div');
                    container.className = 'smart-widget-simultaneous';
                    container.style.display = 'grid';
                    container.style.gridTemplateColumns = `repeat(${Math.min(simultaneousMax, subWidgets.length)}, 1fr)`;
                    container.style.gap = '15px';
                    container.style.height = '100%';
                    
                    subWidgets.slice(0, simultaneousMax).forEach(subWidget => {
                        const subDiv = renderSubWidget(subWidget);
                        if (subDiv) container.appendChild(subDiv);
                    });
                    
                    content.appendChild(container);
                    
                    // Clear cycling interval in simultaneous mode
                    if (smartWidgetCycleInterval) {
                        clearInterval(smartWidgetCycleInterval);
                        smartWidgetCycleInterval = null;
                    }
                } else if (displayMode === 'priority') {
                    // Show only the highest priority sub-widget with content
                    if (subWidgets.length > 0) {
                        const subDiv = renderSubWidget(subWidgets[0]);
                        if (subDiv) content.appendChild(subDiv);
                    }
                    
                    // Clear cycling interval in priority mode
                    if (smartWidgetCycleInterval) {
                        clearInterval(smartWidgetCycleInterval);
                        smartWidgetCycleInterval = null;
                    }
                } else {
                    // Cycle mode - show one at a time, cycling through them
                    
                    // Check if it's party day and party widget is present
                    const partyWidget = subWidgets.find(sw => sw.type === 'party' && sw.isPartyDay);
                    
                    if (partyWidget) {
                        // On party day, show ONLY the party widget without cycling
                        const subDiv = renderSubWidget(partyWidget);
                        if (subDiv) content.appendChild(subDiv);
                        
                        // Store party day flag to prevent cycling
                        content.dataset.isPartyDay = 'true';
                        
                        // Clear cycling interval on party day
                        if (smartWidgetCycleInterval) {
                            clearInterval(smartWidgetCycleInterval);
                            smartWidgetCycleInterval = null;
                        }
                    } else {
                        // Normal cycling behavior
                        content.dataset.isPartyDay = 'false';
                        
                        // Initialize or get current cycle index
                        if (!content.dataset.cycleIndex) {
                            content.dataset.cycleIndex = '0';
                        }
                        
                        const currentIndex = parseInt(content.dataset.cycleIndex) % subWidgets.length;
                        const currentWidget = subWidgets[currentIndex];
                        const subDiv = renderSubWidget(currentWidget);
                        if (subDiv) content.appendChild(subDiv);
                        
                        // Get the current widget's cycle time
                        const widgetCycleTime = (currentWidget.cycleTime || 10) * 1000; // Convert to milliseconds
                        
                        // Set up cycling interval for this specific widget's duration
                        // Clear any existing interval first
                        if (smartWidgetCycleInterval) {
                            clearInterval(smartWidgetCycleInterval);
                        }
                        
                        // Set up new interval with current widget's cycle time
                        smartWidgetCycleInterval = setInterval(() => {
                            // Move to next widget
                            const nextIndex = (parseInt(content.dataset.cycleIndex) + 1) % subWidgets.length;
                            content.dataset.cycleIndex = String(nextIndex);
                            
                            // Update the widget display
                            updateSmartWidget(content, widgetConfig);
                        }, widgetCycleTime);
                        
                        // Update cycle index for next render
                        content.dataset.cycleIndex = String((currentIndex + 1) % subWidgets.length);
                    }
                }
                
            } catch (error) {
                console.error('Error fetching Smart Widget data:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                
                const iconDiv = document.createElement('div');
                iconDiv.style.fontSize = '2rem';
                iconDiv.style.marginBottom = '10px';
                iconDiv.textContent = 'âš ï¸';
                errorDiv.appendChild(iconDiv);
                
                const msgDiv = document.createElement('div');
                msgDiv.textContent = error.message || 'Error loading Smart Widget';
                errorDiv.appendChild(msgDiv);
                
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Render individual sub-widget
        function renderSubWidget(subWidget) {
            const container = document.createElement('div');
            container.className = `smart-sub-widget smart-sub-widget-${subWidget.type}`;
            container.style.padding = '15px';
            container.style.borderRadius = '10px';
            container.style.background = 'rgba(255, 255, 255, 0.05)';
            
            let innerContent = null;
            switch (subWidget.type) {
                case 'rainForecast':
                    innerContent = renderRainForecast(subWidget.data);
                    break;
                case 'upcomingVacation':
                    innerContent = renderUpcomingVacation(subWidget.data);
                    break;
                case 'homeAssistantMedia':
                    innerContent = renderHomeAssistantMedia(subWidget.data);
                    break;
                case 'party':
                    innerContent = renderParty(subWidget.data);
                    break;
                default:
                    return null;
            }
            
            // If the render function returned null (no content), return null
            if (!innerContent) {
                return null;
            }
            
            // Wrap the inner content in the styled container
            container.appendChild(innerContent);
            return container;
        }
        
        // Render rain forecast sub-widget
        function renderRainForecast(data) {
            const container = document.createElement('div');
            container.className = 'rain-forecast-widget';
            container.style.textAlign = 'center';
            
            const iconDiv = document.createElement('div');
            iconDiv.style.fontSize = '2.5rem';
            iconDiv.style.marginBottom = '10px';
            iconDiv.textContent = 'ðŸŒ§ï¸';
            container.appendChild(iconDiv);
            
            const titleDiv = document.createElement('div');
            titleDiv.style.fontSize = '1.2rem';
            titleDiv.style.fontWeight = '600';
            titleDiv.style.marginBottom = '8px';
            titleDiv.textContent = 'Rain Expected';
            container.appendChild(titleDiv);
            
            // Show the earliest rain day
            if (data.rainDays && data.rainDays.length > 0) {
                const nextRain = data.rainDays[0];
                const daysText = nextRain.daysFromNow === 0 ? 'Today' :
                               nextRain.daysFromNow === 1 ? 'Tomorrow' :
                               `In ${nextRain.daysFromNow} days`;
                
                const dayDiv = document.createElement('div');
                dayDiv.style.fontSize = '1rem';
                dayDiv.style.marginBottom = '5px';
                dayDiv.textContent = daysText;
                container.appendChild(dayDiv);
                
                if (nextRain.precipitation > 0) {
                    const probDiv = document.createElement('div');
                    probDiv.style.fontSize = '0.9rem';
                    probDiv.style.opacity = '0.8';
                    probDiv.textContent = `${Math.round(nextRain.precipitation * 100)}% chance`;
                    container.appendChild(probDiv);
                }
            }
            
            return container;
        }
        
        // Render upcoming vacation sub-widget
        function renderUpcomingVacation(data) {
            const container = document.createElement('div');
            container.className = 'vacation-widget';
            container.style.textAlign = 'center';
            
            // Handle multiple vacations
            const vacations = data.vacations || [data];
            
            // Header with icon
            const headerDiv = document.createElement('div');
            headerDiv.style.fontSize = '2.5rem';
            headerDiv.style.marginBottom = '10px';
            headerDiv.textContent = 'âœˆï¸';
            container.appendChild(headerDiv);
            
            // Display each vacation
            vacations.forEach((vacation, index) => {
                const vacationDiv = document.createElement('div');
                vacationDiv.style.marginBottom = index < vacations.length - 1 ? '15px' : '0';
                vacationDiv.style.paddingBottom = index < vacations.length - 1 ? '15px' : '0';
                if (index < vacations.length - 1) {
                    vacationDiv.style.borderBottom = '1px solid rgba(255, 255, 255, 0.2)';
                }
                
                const destDiv = document.createElement('div');
                destDiv.style.fontSize = '1.2rem';
                destDiv.style.fontWeight = '600';
                destDiv.style.marginBottom = '8px';
                destDiv.textContent = vacation.destination;
                vacationDiv.appendChild(destDiv);
                
                const daysDiv = document.createElement('div');
                daysDiv.style.fontSize = '1rem';
                daysDiv.style.marginBottom = '5px';
                
                if (vacation.daysUntil === 0) {
                    daysDiv.textContent = 'Starts Today!';
                    daysDiv.style.color = '#4CAF50';
                } else if (vacation.daysUntil === 1) {
                    daysDiv.textContent = 'Tomorrow';
                } else {
                    daysDiv.textContent = `In ${vacation.daysUntil} days`;
                }
                vacationDiv.appendChild(daysDiv);
                
                const dateDiv = document.createElement('div');
                dateDiv.style.fontSize = '0.9rem';
                dateDiv.style.opacity = '0.8';
                const startDate = new Date(vacation.startDate);
                dateDiv.textContent = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    year: 'numeric'
                });
                vacationDiv.appendChild(dateDiv);
                
                // Add flight information if tracking enabled and flights exist
                if (vacation.flightTrackingEnabled && vacation.flights && vacation.flights.length > 0) {
                    const validatedFlights = vacation.flights.filter(f => f.validated);
                    if (validatedFlights.length > 0) {
                        const flightDiv = document.createElement('div');
                        flightDiv.style.marginTop = '10px';
                        flightDiv.style.fontSize = '0.85rem';
                        flightDiv.style.opacity = '0.9';
                        flightDiv.style.padding = '8px';
                        flightDiv.style.background = 'rgba(255, 255, 255, 0.05)';
                        flightDiv.style.borderRadius = '5px';
                        
                        // Show first flight only in compact view
                        const flight = validatedFlights[0];
                        const flightInfoDiv = document.createElement('div');
                        flightInfoDiv.style.display = 'flex';
                        flightInfoDiv.style.alignItems = 'center';
                        flightInfoDiv.style.justifyContent = 'center';
                        flightInfoDiv.style.gap = '6px';
                        
                        const planeIcon = document.createElement('span');
                        planeIcon.textContent = 'âœˆï¸';
                        flightInfoDiv.appendChild(planeIcon);
                        
                        const flightNum = document.createElement('span');
                        flightNum.style.fontWeight = '600';
                        flightNum.textContent = flight.flightNumber;
                        flightInfoDiv.appendChild(flightNum);
                        
                        flightDiv.appendChild(flightInfoDiv);
                        
                        // If multiple flights, show count
                        if (validatedFlights.length > 1) {
                            const countDiv = document.createElement('div');
                            countDiv.style.fontSize = '0.75rem';
                            countDiv.style.opacity = '0.7';
                            countDiv.style.marginTop = '4px';
                            countDiv.textContent = `+${validatedFlights.length - 1} more`;
                            flightDiv.appendChild(countDiv);
                        }
                        
                        vacationDiv.appendChild(flightDiv);
                    }
                }
                
                container.appendChild(vacationDiv);
            });
            
            return container;
        }
        
        // Render Home Assistant media sub-widget
        function renderHomeAssistantMedia(data) {
            const container = document.createElement('div');
            container.className = 'media-widget';
            
            if (!data.players || data.players.length === 0) {
                return null;
            }
            
            // Show first active player
            const player = data.players[0];
            
            // Container layout
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.alignItems = 'center';
            container.style.gap = '10px';
            
            // Artwork (if available)
            if (player.artwork) {
                const artDiv = document.createElement('div');
                artDiv.style.width = '80px';
                artDiv.style.height = '80px';
                artDiv.style.borderRadius = '8px';
                artDiv.style.overflow = 'hidden';
                artDiv.style.marginBottom = '10px';
                
                const img = document.createElement('img');
                img.src = player.artwork;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.onerror = () => {
                    artDiv.style.display = 'none';
                };
                artDiv.appendChild(img);
                container.appendChild(artDiv);
            }
            
            // Icon (if no artwork)
            if (!player.artwork) {
                const iconDiv = document.createElement('div');
                iconDiv.style.fontSize = '2.5rem';
                iconDiv.style.marginBottom = '10px';
                iconDiv.textContent = player.state === 'playing' ? 'â–¶ï¸' : 'â¸ï¸';
                container.appendChild(iconDiv);
            }
            
            // Title
            const titleDiv = document.createElement('div');
            titleDiv.style.fontSize = '1.1rem';
            titleDiv.style.fontWeight = '600';
            titleDiv.style.textAlign = 'center';
            titleDiv.style.marginBottom = '5px';
            titleDiv.textContent = player.title || 'Unknown';
            container.appendChild(titleDiv);
            
            // Artist
            if (player.artist) {
                const artistDiv = document.createElement('div');
                artistDiv.style.fontSize = '0.9rem';
                artistDiv.style.opacity = '0.8';
                artistDiv.style.textAlign = 'center';
                artistDiv.textContent = player.artist;
                container.appendChild(artistDiv);
            }
            
            // Player name
            const playerDiv = document.createElement('div');
            playerDiv.style.fontSize = '0.8rem';
            playerDiv.style.opacity = '0.6';
            playerDiv.style.textAlign = 'center';
            playerDiv.style.marginTop = '5px';
            playerDiv.textContent = player.friendlyName || player.entityId;
            container.appendChild(playerDiv);
            
            return container;
        }
        
        // Render party sub-widget
        function renderParty(data) {
            // Validate required data exists
            if (!data || !data.dateTime || !data.dateTime.date || data.daysUntil === undefined) {
                console.error('Party widget: Missing required data', data);
                return null;
            }
            
            const PARTY_WIDGET_MAX_HEIGHT = '80vh'; // Maximum height for scrollable content
            
            const container = document.createElement('div');
            container.className = 'party-widget';
            container.style.padding = '10px';
            container.style.maxHeight = PARTY_WIDGET_MAX_HEIGHT;
            container.style.overflowY = 'auto';
            
            // Determine phase
            const isDuringParty = data.phase === 'during';
            
            // Header with icon
            const headerDiv = document.createElement('div');
            headerDiv.style.textAlign = 'center';
            headerDiv.style.marginBottom = '12px';
            
            const iconDiv = document.createElement('div');
            iconDiv.style.fontSize = '2rem';
            iconDiv.style.marginBottom = '5px';
            iconDiv.textContent = 'ðŸŽ‰';
            headerDiv.appendChild(iconDiv);
            
            const titleDiv = document.createElement('div');
            titleDiv.style.fontSize = '1.1rem';
            titleDiv.style.fontWeight = '600';
            
            if (data.daysUntil === 0) {
                titleDiv.textContent = isDuringParty ? 'Party in Progress!' : 'Party Today!';
                titleDiv.style.color = '#4CAF50';
            } else if (data.daysUntil === 1) {
                titleDiv.textContent = 'Party Tomorrow';
            } else {
                titleDiv.textContent = `Party in ${data.daysUntil} days`;
            }
            headerDiv.appendChild(titleDiv);
            
            // Phase indicator
            const phaseDiv = document.createElement('div');
            phaseDiv.style.fontSize = '0.75rem';
            phaseDiv.style.opacity = '0.7';
            phaseDiv.style.marginTop = '3px';
            phaseDiv.textContent = isDuringParty ? 'ðŸŽŠ Enjoy the party!' : 'ðŸ“‹ Party Planning';
            headerDiv.appendChild(phaseDiv);
            
            // Date and time
            if (data.dateTime.date) {
                const dateDiv = document.createElement('div');
                dateDiv.style.fontSize = '0.85rem';
                dateDiv.style.opacity = '0.8';
                dateDiv.style.marginTop = '3px';
                
                try {
                    // Parse date in local timezone by extracting components
                    // Expect YYYY-MM-DD format from server
                    const dateParts = data.dateTime.date.split('-');
                    if (dateParts.length !== 3) {
                        throw new Error(`Invalid date format: expected YYYY-MM-DD, received: ${data.dateTime.date}`);
                    }
                    const partyDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                    
                    // Validate parsed date
                    if (isNaN(partyDate.getTime())) {
                        throw new Error(`Invalid date value after parsing: ${data.dateTime.date}`);
                    }
                    
                    let dateText = partyDate.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric',
                        year: 'numeric'
                    });
                    
                    if (data.dateTime.startTime) {
                        dateText += ` at ${data.dateTime.startTime}`;
                    }
                    
                    dateDiv.textContent = dateText;
                    headerDiv.appendChild(dateDiv);
                } catch (err) {
                    console.error('Party widget: Error parsing date', err.message);
                    // Validate date string format before displaying as fallback
                    // Only display if it matches expected pattern to prevent potential issues
                    if (/^\d{4}-\d{2}-\d{2}$/.test(data.dateTime.date)) {
                        dateDiv.textContent = data.dateTime.date;
                        if (data.dateTime.startTime) {
                            dateDiv.textContent += ` at ${data.dateTime.startTime}`;
                        }
                        headerDiv.appendChild(dateDiv);
                    } else {
                        console.error('Party widget: Date format validation failed, hiding date display');
                        // Don't display invalid date format
                    }
                }
            }
            
            container.appendChild(headerDiv);
            
            // Weather section
            if (data.weather && data.weather.summary) {
                const weatherSection = document.createElement('div');
                weatherSection.style.marginTop = '12px';
                weatherSection.style.marginBottom = '12px';
                weatherSection.style.padding = '10px';
                weatherSection.style.background = 'rgba(255, 255, 255, 0.05)';
                weatherSection.style.borderRadius = '8px';
                weatherSection.style.textAlign = 'center';
                
                const weatherHeader = document.createElement('div');
                weatherHeader.style.fontSize = '0.8rem';
                weatherHeader.style.opacity = '0.7';
                weatherHeader.style.marginBottom = '6px';
                weatherHeader.textContent = 'ðŸŒ¤ï¸ Weather Forecast';
                weatherSection.appendChild(weatherHeader);
                
                // Daily summary - always shown
                const summaryDiv = document.createElement('div');
                summaryDiv.style.marginBottom = '8px';
                
                // Weather icon
                const iconCode = data.weather.summary.icon;
                const iconUrl = iconCode ? `https://openweathermap.org/img/wn/${iconCode}@2x.png` : '';
                if (iconUrl) {
                    const iconImg = document.createElement('img');
                    iconImg.src = iconUrl;
                    iconImg.style.width = '40px';
                    iconImg.style.height = '40px';
                    iconImg.style.verticalAlign = 'middle';
                    summaryDiv.appendChild(iconImg);
                }
                
                // Temperature range
                const tempDiv = document.createElement('div');
                tempDiv.style.fontSize = '0.9rem';
                tempDiv.style.fontWeight = '600';
                const tempUnit = data.weather.units === 'imperial' ? 'Â°F' : 'Â°C';
                tempDiv.textContent = `${data.weather.summary.tempHigh}${tempUnit} / ${data.weather.summary.tempLow}${tempUnit}`;
                summaryDiv.appendChild(tempDiv);
                
                // Condition and precipitation
                const conditionDiv = document.createElement('div');
                conditionDiv.style.fontSize = '0.75rem';
                conditionDiv.style.opacity = '0.8';
                conditionDiv.style.marginTop = '3px';
                conditionDiv.textContent = data.weather.summary.condition;
                if (data.weather.summary.precipChance > 0) {
                    conditionDiv.textContent += ` Â· ${data.weather.summary.precipChance}% precip`;
                }
                summaryDiv.appendChild(conditionDiv);
                
                weatherSection.appendChild(summaryDiv);
                
                // Hourly forecast - shown only within 3 days of party
                if (data.weather.hourly && data.weather.hourly.length > 0) {
                    const hourlyDiv = document.createElement('div');
                    hourlyDiv.style.marginTop = '10px';
                    hourlyDiv.style.paddingTop = '8px';
                    hourlyDiv.style.borderTop = '1px solid rgba(255, 255, 255, 0.1)';
                    
                    const hourlyHeader = document.createElement('div');
                    hourlyHeader.style.fontSize = '0.75rem';
                    hourlyHeader.style.opacity = '0.7';
                    hourlyHeader.style.marginBottom = '6px';
                    hourlyHeader.textContent = 'Hour-by-hour';
                    hourlyDiv.appendChild(hourlyHeader);
                    
                    const hourlyContainer = document.createElement('div');
                    hourlyContainer.style.display = 'flex';
                    hourlyContainer.style.flexWrap = 'wrap';
                    hourlyContainer.style.gap = '8px';
                    hourlyContainer.style.justifyContent = 'center';
                    
                    // Show up to 8 hourly forecasts
                    const hoursToShow = data.weather.hourly.slice(0, 8);
                    hoursToShow.forEach(hourData => {
                        const hourItem = document.createElement('div');
                        hourItem.style.textAlign = 'center';
                        hourItem.style.flex = '0 0 auto';
                        hourItem.style.minWidth = '50px';
                        
                        // Hour label
                        const hourLabel = document.createElement('div');
                        hourLabel.style.fontSize = '0.7rem';
                        hourLabel.style.opacity = '0.7';
                        const hour12 = hourData.hour % 12 || 12;
                        const ampm = hourData.hour < 12 ? 'am' : 'pm';
                        hourLabel.textContent = `${hour12}${ampm}`;
                        hourItem.appendChild(hourLabel);
                        
                        // Weather icon
                        if (hourData.icon) {
                            const hourIconImg = document.createElement('img');
                            hourIconImg.src = `https://openweathermap.org/img/wn/${hourData.icon}.png`;
                            hourIconImg.style.width = '30px';
                            hourIconImg.style.height = '30px';
                            hourItem.appendChild(hourIconImg);
                        }
                        
                        // Temperature
                        const hourTemp = document.createElement('div');
                        hourTemp.style.fontSize = '0.75rem';
                        hourTemp.style.fontWeight = '600';
                        hourTemp.textContent = `${hourData.temp}${tempUnit}`;
                        hourItem.appendChild(hourTemp);
                        
                        // Precipitation chance (if significant)
                        if (hourData.precipChance > 20) {
                            const precipDiv = document.createElement('div');
                            precipDiv.style.fontSize = '0.65rem';
                            precipDiv.style.opacity = '0.7';
                            precipDiv.textContent = `${hourData.precipChance}%`;
                            hourItem.appendChild(precipDiv);
                        }
                        
                        hourlyContainer.appendChild(hourItem);
                    });
                    
                    hourlyDiv.appendChild(hourlyContainer);
                    weatherSection.appendChild(hourlyDiv);
                }
                
                // Weather source note
                const sourceDiv = document.createElement('div');
                sourceDiv.style.fontSize = '0.65rem';
                sourceDiv.style.opacity = '0.5';
                sourceDiv.style.marginTop = '6px';
                sourceDiv.textContent = 'OpenWeatherMap';
                weatherSection.appendChild(sourceDiv);
                
                container.appendChild(weatherSection);
            }
            
            // Content section - Two-column layout for better space utilization
            const contentDiv = document.createElement('div');
            contentDiv.style.fontSize = '1rem';
            contentDiv.style.marginTop = '15px';
            contentDiv.style.display = 'grid';
            contentDiv.style.gridTemplateColumns = 'repeat(auto-fit, minmax(280px, 1fr))';
            contentDiv.style.gap = '20px';
            contentDiv.style.alignItems = 'start';
            
            // Pre-party phase: Show tasks, invitees, menu, events
            // During party phase: Show events, menu, invitees (NO tasks)
            
            // Tasks - only show in pre-party phase
            if (!isDuringParty && data.tasks && data.tasks.list && data.tasks.list.length > 0) {
                const tasksSection = document.createElement('div');
                tasksSection.style.marginBottom = '15px';
                
                const tasksHeader = document.createElement('div');
                tasksHeader.style.fontWeight = '600';
                tasksHeader.style.marginBottom = '10px';
                tasksHeader.style.fontSize = '1.05rem';
                tasksHeader.innerHTML = 'âœ“ To-Do Items';
                tasksSection.appendChild(tasksHeader);
                
                data.tasks.list.forEach(task => {
                    const taskItem = document.createElement('div');
                    taskItem.style.marginBottom = '6px';
                    taskItem.style.paddingLeft = '12px';
                    taskItem.style.opacity = task.completed ? '0.6' : '1';
                    taskItem.style.fontSize = '0.95rem';
                    
                    const checkbox = document.createElement('span');
                    checkbox.textContent = task.completed ? 'â˜‘' : 'â˜';
                    checkbox.style.marginRight = '8px';
                    checkbox.style.fontSize = '1rem';
                    
                    const taskText = document.createElement('span');
                    taskText.textContent = task.name;
                    if (task.completed) {
                        taskText.style.textDecoration = 'line-through';
                    }
                    
                    taskItem.appendChild(checkbox);
                    taskItem.appendChild(taskText);
                    
                    if (task.assignee) {
                        const assigneeText = document.createElement('span');
                        assigneeText.textContent = ` (${task.assignee})`;
                        assigneeText.style.opacity = '0.7';
                        assigneeText.style.fontSize = '0.85rem';
                        taskItem.appendChild(assigneeText);
                    }
                    
                    tasksSection.appendChild(taskItem);
                });
                
                contentDiv.appendChild(tasksSection);
            }
            
            // Events - show in both phases, but prioritize during party
            if (data.events && data.events.length > 0) {
                const eventsSection = document.createElement('div');
                eventsSection.style.marginBottom = '15px';
                
                const eventsHeader = document.createElement('div');
                eventsHeader.style.fontWeight = '600';
                eventsHeader.style.marginBottom = '10px';
                eventsHeader.style.fontSize = '1.05rem';
                eventsHeader.innerHTML = 'ðŸ“‹ Events Schedule';
                eventsSection.appendChild(eventsHeader);
                
                data.events.forEach(event => {
                    const eventItem = document.createElement('div');
                    eventItem.style.marginBottom = '10px';
                    eventItem.style.paddingLeft = '12px';
                    
                    const eventTitle = document.createElement('div');
                    eventTitle.style.fontWeight = '500';
                    eventTitle.style.fontSize = '0.95rem';
                    
                    if (event.time) {
                        const timeSpan = document.createElement('span');
                        timeSpan.textContent = event.time + ' - ';
                        timeSpan.style.color = '#4CAF50';
                        timeSpan.style.fontWeight = '600';
                        eventTitle.appendChild(timeSpan);
                    }
                    
                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = event.title;
                    eventTitle.appendChild(titleSpan);
                    
                    eventItem.appendChild(eventTitle);
                    
                    if (event.description) {
                        const eventDesc = document.createElement('div');
                        eventDesc.textContent = event.description;
                        eventDesc.style.fontSize = '0.85rem';
                        eventDesc.style.opacity = '0.7';
                        eventDesc.style.marginTop = '4px';
                        eventItem.appendChild(eventDesc);
                    }
                    
                    eventsSection.appendChild(eventItem);
                });
                
                contentDiv.appendChild(eventsSection);
            }
            
            // Menu - show in both phases with different info based on phase
            if (data.menu && data.menu.length > 0) {
                const menuSection = document.createElement('div');
                menuSection.style.marginBottom = '15px';
                
                const menuHeader = document.createElement('div');
                menuHeader.style.fontWeight = '600';
                menuHeader.style.marginBottom = '10px';
                menuHeader.style.fontSize = '1.05rem';
                menuHeader.innerHTML = isDuringParty ? 'ðŸ½ï¸ Menu' : 'ðŸ½ï¸ Menu & Assignments';
                menuSection.appendChild(menuHeader);
                
                data.menu.forEach(item => {
                    const menuItem = document.createElement('div');
                    menuItem.style.marginBottom = '10px';
                    menuItem.style.paddingLeft = '12px';
                    
                    const itemName = document.createElement('div');
                    itemName.style.fontWeight = '500';
                    itemName.style.fontSize = '0.95rem';
                    // Handle both 'item' and 'name' properties for backwards compatibility
                    itemName.textContent = item.item || item.name;
                    menuItem.appendChild(itemName);
                    
                    // Before party: Show assignee (who's responsible)
                    // During party: Show description
                    if (!isDuringParty && item.assignee) {
                        const assigneeDiv = document.createElement('div');
                        assigneeDiv.textContent = `ðŸ‘¤ ${item.assignee}`;
                        assigneeDiv.style.fontSize = '0.85rem';
                        assigneeDiv.style.opacity = '0.7';
                        assigneeDiv.style.marginTop = '4px';
                        assigneeDiv.style.fontStyle = 'italic';
                        menuItem.appendChild(assigneeDiv);
                    }
                    
                    if (isDuringParty && item.description) {
                        const itemDesc = document.createElement('div');
                        itemDesc.textContent = item.description;
                        itemDesc.style.fontSize = '0.85rem';
                        itemDesc.style.opacity = '0.7';
                        itemDesc.style.marginTop = '4px';
                        menuItem.appendChild(itemDesc);
                    }
                    
                    menuSection.appendChild(menuItem);
                });
                
                contentDiv.appendChild(menuSection);
            }
            
            // Invitees - show in both phases
            if (data.invitees && data.invitees.list && data.invitees.list.length > 0) {
                const inviteesSection = document.createElement('div');
                inviteesSection.style.marginBottom = '15px';
                
                const inviteesHeader = document.createElement('div');
                inviteesHeader.style.fontWeight = '600';
                inviteesHeader.style.marginBottom = '10px';
                inviteesHeader.style.fontSize = '1.05rem';
                inviteesHeader.innerHTML = 'ðŸ‘¥ Guest List';
                inviteesSection.appendChild(inviteesHeader);
                
                // Group by RSVP status
                const coming = data.invitees.list.filter(i => i.rsvp === 'coming');
                const pending = data.invitees.list.filter(i => i.rsvp === 'pending');
                const notComing = data.invitees.list.filter(i => i.rsvp === 'not-coming');
                
                if (coming.length > 0) {
                    const comingLabel = document.createElement('div');
                    comingLabel.style.fontSize = '0.85rem';
                    comingLabel.style.opacity = '0.7';
                    comingLabel.style.marginTop = '6px';
                    comingLabel.style.marginBottom = '4px';
                    comingLabel.textContent = 'Coming:';
                    inviteesSection.appendChild(comingLabel);
                    
                    coming.forEach(invitee => {
                        const inviteeItem = document.createElement('div');
                        inviteeItem.style.paddingLeft = '12px';
                        inviteeItem.style.marginBottom = '3px';
                        inviteeItem.style.fontSize = '0.9rem';
                        inviteeItem.textContent = `âœ“ ${invitee.name}`;
                        inviteeItem.style.color = '#4CAF50';
                        inviteesSection.appendChild(inviteeItem);
                    });
                }
                
                if (pending.length > 0) {
                    const pendingLabel = document.createElement('div');
                    pendingLabel.style.fontSize = '0.85rem';
                    pendingLabel.style.opacity = '0.7';
                    pendingLabel.style.marginTop = '6px';
                    pendingLabel.style.marginBottom = '4px';
                    pendingLabel.textContent = 'Pending:';
                    inviteesSection.appendChild(pendingLabel);
                    
                    pending.forEach(invitee => {
                        const inviteeItem = document.createElement('div');
                        inviteeItem.style.paddingLeft = '12px';
                        inviteeItem.style.marginBottom = '3px';
                        inviteeItem.style.fontSize = '0.9rem';
                        inviteeItem.textContent = `? ${invitee.name}`;
                        inviteeItem.style.color = '#FFC107';
                        inviteesSection.appendChild(inviteeItem);
                    });
                }
                
                if (notComing.length > 0) {
                    const notComingLabel = document.createElement('div');
                    notComingLabel.style.fontSize = '0.85rem';
                    notComingLabel.style.opacity = '0.7';
                    notComingLabel.style.marginTop = '6px';
                    notComingLabel.style.marginBottom = '4px';
                    notComingLabel.textContent = 'Not Coming:';
                    inviteesSection.appendChild(notComingLabel);
                    
                    notComing.forEach(invitee => {
                        const inviteeItem = document.createElement('div');
                        inviteeItem.style.paddingLeft = '12px';
                        inviteeItem.style.marginBottom = '3px';
                        inviteeItem.style.fontSize = '0.9rem';
                        inviteeItem.textContent = `âœ— ${invitee.name}`;
                        inviteeItem.style.opacity = '0.5';
                        inviteesSection.appendChild(inviteeItem);
                    });
                }
                
                contentDiv.appendChild(inviteesSection);
            }
            
            container.appendChild(contentDiv);
            
            return container;
        }
        
        // Helper function to format date range
        function formatDateRange(startDate, endDate) {
            const options = { month: 'short', day: 'numeric' };
            const start = startDate.toLocaleDateString('en-US', options);
            const end = endDate.toLocaleDateString('en-US', options);
            
            if (startDate.getFullYear() !== new Date().getFullYear()) {
                return `${start}, ${startDate.getFullYear()} - ${end}, ${endDate.getFullYear()}`;
            }
            
            return `${start} - ${end}`;
        }

        // Show error message
        function showError(message) {
            const container = document.getElementById('dashboardContainer');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            container.innerHTML = '';
            container.appendChild(errorDiv);
        }

        // Initialize dashboard on page load
        let clockInterval = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            
            // Update clock every second
            clockInterval = setInterval(() => {
                if (config && config.widgets && config.widgets.clock && config.widgets.clock.enabled) {
                    const clockElement = document.getElementById('widget-clock');
                    if (clockElement) {
                        updateClockWidget(clockElement, config.widgets.clock);
                    }
                }
            }, 1000);
            
            // Listen for orientation changes (only if not using URL-based orientation)
            if (window.location.pathname !== '/smart-mirror-l' && window.matchMedia) {
                const portraitMedia = window.matchMedia('(orientation: portrait)');
                const landscapeMedia = window.matchMedia('(orientation: landscape)');
                
                const handleOrientationChange = (e) => {
                    const newOrientation = detectOrientation();
                    if (newOrientation !== currentOrientation) {
                        console.log(`[Smart Mirror] Orientation changed: ${currentOrientation} -> ${newOrientation}`);
                        currentOrientation = newOrientation;
                        
                        // Reload config and re-render dashboard
                        loadConfig();
                    }
                };
                
                // Add listeners for both orientations
                portraitMedia.addEventListener('change', handleOrientationChange);
                landscapeMedia.addEventListener('change', handleOrientationChange);
                
                console.log('[Smart Mirror] Orientation change listeners added');
            } else if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Using landscape URL - orientation locked to landscape');
            } else {
                console.log('[Smart Mirror] Using portrait URL - orientation locked to portrait');
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });
    </script>
</body>
</html>
