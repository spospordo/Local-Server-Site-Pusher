<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Mirror Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body.theme-light {
            background: #f5f5f5;
            color: #333;
        }

        .dashboard-container {
            display: grid;
            /* Grid dimensions are set dynamically via JavaScript */
            gap: 20px;
            padding: 20px;
            height: 100vh;
            width: 100vw;
        }

        .widget {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Enforce strict grid sizing - prevent content from expanding widget */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        body.theme-light .widget {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .widget-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .widget-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* Enforce content containment within widget bounds */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        /* Clock Widget */
        .clock-time {
            font-size: 4rem;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .clock-time-24h {
            font-size: 2.4rem; /* 60% of main clock size */
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            margin-top: 8px;
            opacity: 0.6;
            color: #999;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        body.theme-light .clock-time-24h {
            color: #666;
        }

        .clock-date {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Calendar Widget */
        .calendar-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            /* Ensure calendar container doesn't expand beyond widget */
            min-height: 0;
        }

        .calendar-month-view {
            flex-shrink: 0;
        }

        .calendar-header {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
            text-align: center;
            font-size: 0.85rem;
        }

        .calendar-day-name {
            font-weight: 600;
            padding: 4px 2px;
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .calendar-day {
            padding: 6px 2px;
            border-radius: 4px;
            font-size: 0.85rem;
            min-height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-day.today {
            background: rgba(102, 126, 234, 0.6);
            font-weight: 700;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.4);
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.has-event {
            position: relative;
        }

        .calendar-day.has-event::after {
            content: '‚Ä¢';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(102, 126, 234, 0.8);
            font-size: 0.8rem;
        }

        .calendar-events {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
            min-height: 0; /* Critical for flex child scrolling */
            scroll-behavior: smooth;
        }

        .calendar-events::-webkit-scrollbar {
            width: 6px;
        }

        .calendar-events::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.3);
            border-radius: 3px;
        }

        body.theme-light .calendar-events::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
        }

        .calendar-event {
            background: rgba(102, 126, 234, 0.2);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 0.85rem;
            border-left: 3px solid rgba(102, 126, 234, 0.6);
        }

        .calendar-event.all-day {
            border-left-color: rgba(255, 183, 77, 0.8);
            background: rgba(255, 183, 77, 0.15);
        }

        .calendar-event-time {
            font-weight: 600;
            margin-right: 8px;
            color: rgba(102, 126, 234, 0.9);
        }

        .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 183, 77, 0.9);
        }

        body.theme-light .calendar-event-time {
            color: rgba(102, 126, 234, 1);
        }

        body.theme-light .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 152, 0, 1);
        }

        .calendar-event-title {
            font-weight: 500;
        }

        .calendar-event-location {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 3px;
        }

        .calendar-event-description {
            font-size: 0.75em;
            opacity: 0.6;
            margin-top: 4px;
            line-height: 1.3;
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-error {
            opacity: 0.6;
            text-align: center;
            padding: 10px;
            font-size: 0.9rem;
        }

        .calendar-warning {
            background: rgba(255, 183, 77, 0.2);
            border-left: 3px solid rgba(255, 183, 77, 0.6);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        /* Responsive calendar layout for different widget sizes */
        @media (min-width: 1px) {
            /* Small widgets - reduce clock size */
            .widget[data-grid-width="1"] .clock-time {
                font-size: 2rem;
            }

            .widget[data-grid-width="1"] .clock-time-24h {
                font-size: 1.2rem; /* 60% of small widget clock size */
            }
            
            .widget[data-grid-width="1"] .clock-date {
                font-size: 0.8rem;
            }
            
            .widget[data-grid-height="1"] .clock-time {
                font-size: 2.5rem;
            }

            .widget[data-grid-height="1"] .clock-time-24h {
                font-size: 1.5rem; /* 60% of medium widget clock size */
            }
            
            .widget[data-grid-height="1"] .clock-date {
                font-size: 0.9rem;
            }

            /* Small widgets - reduce calendar grid size */
            .widget[data-grid-width="1"] .calendar-grid,
            .widget[data-grid-height="1"] .calendar-grid {
                font-size: 0.7rem;
                gap: 2px;
            }

            .widget[data-grid-width="1"] .calendar-day,
            .widget[data-grid-height="1"] .calendar-day {
                padding: 3px 1px;
                font-size: 0.7rem;
                min-height: 1.2rem;
            }

            .widget[data-grid-width="1"] .calendar-header,
            .widget[data-grid-height="1"] .calendar-header {
                font-size: 0.9rem;
                margin-bottom: 5px;
            }

            .widget[data-grid-width="1"] .calendar-day-name,
            .widget[data-grid-height="1"] .calendar-day-name {
                font-size: 0.6rem;
            }

            /* Medium and large widgets - standard sizing */
            .widget[data-grid-width="2"] .calendar-events,
            .widget[data-grid-width="3"] .calendar-events,
            .widget[data-grid-width="4"] .calendar-events {
                min-height: 120px;
            }

            /* Wide widgets - use horizontal layout if short */
            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-container,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-container {
                flex-direction: row;
                gap: 15px;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-month-view,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-month-view {
                flex-shrink: 0;
                width: 45%;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-events,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-events {
                width: 55%;
                min-height: 0;
            }

            /* Responsive weather widget sizing */
            .widget[data-grid-width="1"] .weather-temp {
                font-size: 2rem;
            }
            
            .widget[data-grid-height="1"] .weather-temp {
                font-size: 2.5rem;
            }
            
            .widget[data-grid-width="1"] .weather-condition,
            .widget[data-grid-height="1"] .weather-condition {
                font-size: 1rem;
            }
            
            .widget[data-grid-width="1"] .weather-icon {
                font-size: 1.5rem;
            }

            /* Responsive forecast widget sizing */
            .widget[data-grid-width="2"] .forecast-day-name {
                font-size: 0.9rem;
            }
            
            .widget[data-grid-height="1"] .forecast-icon {
                font-size: 1.5rem;
            }
            
            .widget[data-grid-height="1"] .forecast-temp {
                font-size: 1rem;
            }
        }

        /* Weather Widget */
        .weather-temp {
            font-size: 3rem;
            font-weight: 300;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .weather-temp-unit {
            font-size: 1.5rem;
            opacity: 0.6;
            margin-left: 5px;
        }
        
        .weather-temp-secondary {
            font-size: 1.8rem; /* 60% of 3rem primary temp */
            opacity: 0.5;
            margin-left: 10px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }

        .weather-condition {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .weather-icon {
            font-size: 2.5rem;
            margin: 10px 0;
        }

        .weather-details {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            flex-wrap: wrap;
        }
        
        .weather-location {
            font-size: 1rem;
            opacity: 0.6;
            margin-top: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Forecast Widget */
        .forecast-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 10px;
            /* Use horizontal scroll without wrap for overflow */
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;
        }
        
        .forecast-day {
            text-align: center;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            min-width: 80px; /* Prevent excessive shrinking */
        }
        
        body.theme-light .forecast-day {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .forecast-day-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .forecast-icon {
            font-size: 2rem;
            margin: 8px 0;
        }
        
        .forecast-temp {
            font-size: 1.2rem;
            margin: 5px 0;
        }
        
        .forecast-temp-high {
            font-weight: 600;
        }
        
        .forecast-temp-low {
            opacity: 0.6;
        }
        
        .forecast-precip {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .forecast-temp-secondary {
            font-size: 0.75rem; /* 60-65% of forecast temps */
            opacity: 0.5;
            margin-top: 3px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .forecast-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }
        
        .weather-feels-like-secondary {
            font-size: 0.7rem;
            opacity: 0.5;
            margin-left: 5px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-feels-like-secondary {
            color: #666; /* Darker gray for light theme */
        }

        /* News Widget */
        .news-items {
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            /* Remove max-height: 100% which can cause expansion */
            flex: 1;
            min-height: 0;
            scroll-behavior: smooth;
        }

        .news-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.theme-light .news-item {
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .news-item:last-child {
            border-bottom: none;
        }

        .news-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 5px;
            /* Truncate long titles */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }

        .news-source {
            font-size: 0.8rem;
            opacity: 0.6;
        }

        /* Media Widget */
        .media-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 10px;
        }

        .media-artwork-container {
            flex: 0 0 auto;
            width: 100%;
            max-height: 60%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-radius: 10px;
        }

        .media-artwork {
            width: 100%;
            height: auto;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
        }

        .media-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 5px;
            min-height: 0;
        }

        .media-title {
            font-size: 1.4rem;
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }

        .media-artist {
            font-size: 1.1rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .media-album {
            font-size: 0.9rem;
            opacity: 0.6;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .media-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .media-platform {
            background: rgba(255, 255, 255, 0.15);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        body.theme-light .media-platform {
            background: rgba(0, 0, 0, 0.1);
        }

        .media-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }

        .media-status-icon {
            font-size: 1.1rem;
        }

        .media-idle {
            text-align: center;
            opacity: 0.6;
            padding: 20px;
        }

        .media-idle-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        /* Responsive media widget sizing */
        .widget[data-grid-width="1"] .media-title {
            font-size: 1rem;
            -webkit-line-clamp: 1;
        }

        .widget[data-grid-width="1"] .media-artist {
            font-size: 0.9rem;
        }

        .widget[data-grid-height="1"] .media-artwork-container {
            max-height: 40%;
        }

        .widget[data-grid-width="2"][data-grid-height="2"] .media-artwork-container {
            max-height: 50%;
        }

        /* Error message */
        .error-message {
            color: #ff6b6b;
            padding: 20px;
            text-align: center;
            font-size: 1.2rem;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 20px;
            opacity: 0.6;
        }

        /* Responsive grid positioning - combined position and span rules */
        /* Grid positioning rules are generated dynamically via JavaScript */
        /* based on the configured grid size for each orientation */

        /* Scrollbar styling for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        body.theme-light ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
        }

        body.theme-light ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="dashboard-container" id="dashboardContainer">
        <div class="loading">Loading Smart Mirror Dashboard...</div>
    </div>

    <script>
        let config = null;
        let refreshInterval = null;
        let currentOrientation = 'portrait'; // Track current orientation

        // Detect current orientation from URL or screen
        function detectOrientation() {
            // Check URL first
            if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Orientation: landscape (from URL)');
                return 'landscape';
            }
            
            // Try to detect from screen orientation
            try {
                if (window.matchMedia) {
                    // Check if screen is wider than tall (landscape)
                    if (window.matchMedia('(orientation: landscape)').matches) {
                        console.log('[Smart Mirror] Orientation: landscape (from matchMedia)');
                        return 'landscape';
                    } else {
                        console.log('[Smart Mirror] Orientation: portrait (from matchMedia)');
                        return 'portrait';
                    }
                }
            } catch (e) {
                console.warn('[Smart Mirror] matchMedia not available:', e);
            }
            
            // Fallback to comparing dimensions
            if (window.innerWidth > window.innerHeight) {
                console.log('[Smart Mirror] Orientation: landscape (from dimensions)');
                return 'landscape';
            }
            
            console.log('[Smart Mirror] Orientation: portrait (default)');
            return 'portrait';
        }

        // Generate and apply dynamic grid CSS based on configuration
        function applyGridCSS(gridSize) {
            console.log('[Smart Mirror] Applying grid CSS:', gridSize);
            
            const container = document.getElementById('dashboardContainer');
            if (!container) return;
            
            // Set grid template
            container.style.gridTemplateColumns = `repeat(${gridSize.columns}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${gridSize.rows}, 1fr)`;
            
            // Generate dynamic positioning CSS rules
            let styleElement = document.getElementById('dynamic-grid-styles');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'dynamic-grid-styles';
                document.head.appendChild(styleElement);
            }
            
            let cssRules = '';
            
            // Generate column positioning rules
            for (let x = 0; x < gridSize.columns; x++) {
                for (let width = 1; width <= gridSize.columns; width++) {
                    if (x + width <= gridSize.columns) {
                        cssRules += `.widget[data-grid-x="${x}"][data-grid-width="${width}"] { grid-column: ${x + 1} / span ${width}; }\n`;
                    }
                }
            }
            
            // Generate row positioning rules
            for (let y = 0; y < gridSize.rows; y++) {
                for (let height = 1; height <= gridSize.rows; height++) {
                    if (y + height <= gridSize.rows) {
                        cssRules += `.widget[data-grid-y="${y}"][data-grid-height="${height}"] { grid-row: ${y + 1} / span ${height}; }\n`;
                    }
                }
            }
            
            styleElement.textContent = cssRules;
            console.log(`[Smart Mirror] Generated ${cssRules.split('\n').length - 1} CSS positioning rules`);
        }

        // Check and update theme based on current time
        async function checkAndUpdateTheme() {
            try {
                console.log('[Smart Mirror] Checking for theme update...');
                const response = await fetch(`/api/smart-mirror/config?orientation=${currentOrientation}`);
                const data = await response.json();
                
                if (data.success && data.config && data.config.calculatedTheme) {
                    const currentTheme = document.body.classList.contains('theme-light') ? 'light' : 'dark';
                    const newTheme = data.config.calculatedTheme;
                    
                    if (currentTheme !== newTheme) {
                        console.log(`[Smart Mirror] Theme switching from ${currentTheme} to ${newTheme}`);
                        if (newTheme === 'light') {
                            document.body.classList.add('theme-light');
                        } else {
                            document.body.classList.remove('theme-light');
                        }
                    } else {
                        console.log(`[Smart Mirror] Theme unchanged: ${currentTheme}`);
                    }
                    
                    // Update config with new theme info
                    if (config) {
                        config.calculatedTheme = data.config.calculatedTheme;
                        config.themeInfo = data.config.themeInfo;
                    }
                }
            } catch (error) {
                console.error('[Smart Mirror] Error checking theme:', error);
            }
        }

        // Load configuration and initialize dashboard
        async function loadConfig() {
            console.log('[Smart Mirror] Loading configuration from API...');
            console.log('[Smart Mirror] Timestamp:', new Date().toISOString());
            console.log('[Smart Mirror] User Agent:', navigator.userAgent);
            console.log('[Smart Mirror] Page URL:', window.location.href);
            
            // Detect orientation
            currentOrientation = detectOrientation();
            console.log(`[Smart Mirror] Current orientation: ${currentOrientation}`);
            
            try {
                const fetchStart = performance.now();
                console.log(`[Smart Mirror] Fetching config from /api/smart-mirror/config?orientation=${currentOrientation}`);
                
                const response = await fetch(`/api/smart-mirror/config?orientation=${currentOrientation}`);
                const fetchEnd = performance.now();
                
                console.log(`[Smart Mirror] API response received (${Math.round(fetchEnd - fetchStart)}ms)`);
                console.log('[Smart Mirror] Response status:', response.status, response.statusText);
                console.log('[Smart Mirror] Response headers:', {
                    contentType: response.headers.get('content-type'),
                    cacheControl: response.headers.get('cache-control')
                });
                
                const data = await response.json();
                console.log('[Smart Mirror] Config data parsed:', {
                    success: data.success,
                    hasConfig: !!data.config,
                    enabled: data.config?.enabled,
                    theme: data.config?.theme,
                    widgetCount: Object.keys(data.config?.widgets || {}).length
                });
                
                if (data.success && data.config) {
                    config = data.config;
                    console.log('‚úÖ [Smart Mirror] Config loaded successfully:', config);
                    console.log('[Smart Mirror] Enabled widgets:', 
                        Object.keys(config.widgets || {}).filter(k => config.widgets[k]?.enabled)
                    );
                    
                    // Apply theme - use calculated theme if available, otherwise manual theme
                    const themeToApply = config.calculatedTheme || config.theme || 'dark';
                    console.log('[Smart Mirror] Theme info:', {
                        manualTheme: config.theme,
                        calculatedTheme: config.calculatedTheme,
                        autoMode: config.themeInfo?.autoMode,
                        nextSwitch: config.themeInfo?.nextSwitch,
                        applying: themeToApply
                    });
                    
                    if (themeToApply === 'light') {
                        console.log('[Smart Mirror] Applying light theme');
                        document.body.classList.add('theme-light');
                    } else {
                        console.log('[Smart Mirror] Using dark theme');
                        document.body.classList.remove('theme-light');
                    }
                    
                    // Set up theme checking interval if auto mode is enabled
                    if (config.themeInfo?.autoMode && config.themeInfo?.nextSwitch) {
                        console.log(`[Smart Mirror] Auto theme mode enabled, next switch at: ${config.themeInfo.nextSwitch}`);
                        // Check theme every minute to handle switches
                        setInterval(checkAndUpdateTheme, 60000); // Check every 60 seconds
                    }
                    
                    // Check if dashboard is enabled
                    if (config.enabled === false) {
                        console.warn('‚ö†Ô∏è  [Smart Mirror] Dashboard is disabled in configuration');
                        showError('Smart Mirror Dashboard is currently disabled. Please enable it in the admin panel.');
                        return;
                    }
                    
                    console.log('[Smart Mirror] Dashboard is enabled, rendering...');
                    
                    // Apply grid CSS based on orientation
                    const gridSize = config.gridSize?.[currentOrientation] || config.gridSize || { columns: 4, rows: 3 };
                    applyGridCSS(gridSize);
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Set up refresh interval
                    if (config.refreshInterval && config.refreshInterval > 0) {
                        console.log(`[Smart Mirror] Setting refresh interval: ${config.refreshInterval}ms`);
                        refreshInterval = setInterval(updateWidgets, config.refreshInterval);
                    }
                } else {
                    console.error('‚ùå [Smart Mirror] Config load failed:', data);
                    showError('Failed to load Smart Mirror configuration.');
                }
            } catch (error) {
                console.error('‚ùå [Smart Mirror] Error loading config:', error);
                console.error('[Smart Mirror] Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                showError('Error connecting to server. Please check your connection.');
            }
        }

        // Render the dashboard with configured widgets
        function renderDashboard() {
            console.log('[Smart Mirror] Starting dashboard render');
            const container = document.getElementById('dashboardContainer');
            container.innerHTML = '';

            if (!config || !config.widgets) {
                console.error('‚ùå [Smart Mirror] No widgets configured');
                showError('No widgets configured.');
                return;
            }

            console.log('[Smart Mirror] Rendering widgets:', Object.keys(config.widgets));
            
            // Get the layout for current orientation
            const layout = config.layouts?.[currentOrientation] || {};
            console.log(`[Smart Mirror] Using ${currentOrientation} layout:`, layout);
            
            // Create array of widgets with their keys for sorting
            const widgetEntries = Object.keys(config.widgets)
                .map(widgetKey => ({
                    key: widgetKey,
                    config: config.widgets[widgetKey],
                    layout: layout[widgetKey] || { x: 0, y: 0, width: 1, height: 1 }
                }))
                .filter(entry => entry.config && entry.config.enabled === true);
            
            // Sort widgets by grid position (y first, then x, then by name as tiebreaker)
            widgetEntries.sort((a, b) => {
                const posA = a.layout || { x: 0, y: 0 };
                const posB = b.layout || { x: 0, y: 0 };
                
                // Sort by y coordinate (row) first
                if (posA.y !== posB.y) {
                    return posA.y - posB.y;
                }
                
                // Then by x coordinate (column)
                if (posA.x !== posB.x) {
                    return posA.x - posB.x;
                }
                
                // If same position, sort alphabetically by widget key for stable ordering
                return a.key.localeCompare(b.key);
            });
            
            console.log('[Smart Mirror] Widget render order:', 
                widgetEntries.map(e => `${e.key}(${e.layout?.x},${e.layout?.y})`).join(', ')
            );
            
            // Create widgets based on sorted configuration
            widgetEntries.forEach(entry => {
                const widgetKey = entry.key;
                const widgetConfig = entry.config;
                const widgetLayout = entry.layout;
                
                console.log(`[Smart Mirror] Processing widget: ${widgetKey}`, {
                    enabled: widgetConfig?.enabled,
                    layout: widgetLayout
                });
                
                const widget = createWidget(widgetKey, widgetConfig, widgetLayout);
                if (widget) {
                    container.appendChild(widget);
                }
            });

            // Start updating dynamic content
            updateWidgets();
        }

        // Create a widget element
        function createWidget(type, widgetConfig, widgetLayout) {
            const widget = document.createElement('div');
            widget.className = 'widget';
            widget.dataset.type = type;
            
            // Set grid position from layout
            const pos = widgetLayout || { x: 0, y: 0, width: 1, height: 1 };
            widget.dataset.gridX = pos.x || 0;
            widget.dataset.gridY = pos.y || 0;
            widget.dataset.gridWidth = pos.width || 1;
            widget.dataset.gridHeight = pos.height || 1;

            // Create widget header
            const header = document.createElement('div');
            header.className = 'widget-header';
            header.textContent = getWidgetTitle(type);
            widget.appendChild(header);

            // Create widget content container
            const content = document.createElement('div');
            content.className = 'widget-content';
            content.id = `widget-${type}`;
            widget.appendChild(content);

            return widget;
        }

        // Get widget title
        function getWidgetTitle(type) {
            const titles = {
                clock: 'üïê Time',
                calendar: 'üìÖ Calendar',
                weather: 'üå§Ô∏è Weather',
                forecast: 'üå¶Ô∏è Forecast',
                news: 'üì∞ News',
                media: 'üéµ Now Playing',
                vacation: '‚úàÔ∏è Upcoming Vacation'
            };
            return titles[type] || type.charAt(0).toUpperCase() + type.slice(1);
        }

        // Update all dynamic widgets
        function updateWidgets() {
            if (!config || !config.widgets) return;

            Object.keys(config.widgets).forEach(widgetKey => {
                const widgetConfig = config.widgets[widgetKey];
                if (widgetConfig && widgetConfig.enabled === true) {
                    updateWidget(widgetKey, widgetConfig);
                }
            });
        }

        // Update individual widget
        function updateWidget(type, widgetConfig) {
            const content = document.getElementById(`widget-${type}`);
            if (!content) return;

            switch (type) {
                case 'clock':
                    updateClockWidget(content);
                    break;
                case 'calendar':
                    updateCalendarWidget(content, widgetConfig);
                    break;
                case 'weather':
                    updateWeatherWidget(content, widgetConfig);
                    break;
                case 'forecast':
                    updateForecastWidget(content, widgetConfig);
                    break;
                case 'news':
                    updateNewsWidget(content, widgetConfig);
                    break;
                case 'media':
                    updateMediaWidget(content, widgetConfig);
                    break;
                case 'vacation':
                    updateVacationWidget(content, widgetConfig);
                    break;
            }
        }

        // Update clock widget
        function updateClockWidget(content) {
            const now = new Date();
            
            const timeStr = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });

            const time24Str = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
            
            const dateStr = now.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            content.innerHTML = `
                <div class="clock-time">${timeStr}</div>
                <div class="clock-time-24h">${time24Str}</div>
                <div class="clock-date">${dateStr}</div>
            `;
        }

        // Update calendar widget
        // Update calendar widget
        async function updateCalendarWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/calendar');
                const data = await response.json();
                
                // Clear content
                content.innerHTML = '';
                
                // Create calendar container
                const calendarContainer = document.createElement('div');
                calendarContainer.className = 'calendar-container';
                
                // Generate monthly calendar grid
                const monthView = renderMonthlyCalendar(data.events || []);
                calendarContainer.appendChild(monthView);
                
                // Show warnings if there are errors
                if (data.errors && data.errors.length > 0) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'calendar-warning';
                    warningDiv.textContent = '‚ö†Ô∏è Some feeds could not be loaded';
                    calendarContainer.appendChild(warningDiv);
                }
                
                // Render events list
                if (data.success && data.events && data.events.length > 0) {
                    const eventsContainer = document.createElement('div');
                    eventsContainer.className = 'calendar-events';
                    
                    data.events.forEach(event => {
                        const eventDiv = renderEvent(event);
                        eventsContainer.appendChild(eventDiv);
                    });
                    
                    calendarContainer.appendChild(eventsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'calendar-error';
                    errorDiv.textContent = '‚ö†Ô∏è ' + data.error;
                    calendarContainer.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'calendar-error';
                    msgDiv.textContent = 'No upcoming events';
                    calendarContainer.appendChild(msgDiv);
                }
                
                content.appendChild(calendarContainer);
            } catch (error) {
                console.error('Error fetching calendar:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'calendar-error';
                errorDiv.textContent = 'Error loading calendar';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Render monthly calendar grid
        function renderMonthlyCalendar(events) {
            const monthView = document.createElement('div');
            monthView.className = 'calendar-month-view';
            
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            
            // Create header with month/year
            const header = document.createElement('div');
            header.className = 'calendar-header';
            header.textContent = now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            monthView.appendChild(header);
            
            // Create calendar grid
            const grid = document.createElement('div');
            grid.className = 'calendar-grid';
            
            // Day names
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(day => {
                const dayNameDiv = document.createElement('div');
                dayNameDiv.className = 'calendar-day-name';
                dayNameDiv.textContent = day;
                grid.appendChild(dayNameDiv);
            });
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Create a map of dates with events
            const eventDates = new Set();
            events.forEach(event => {
                const eventDate = new Date(event.start);
                if (eventDate.getMonth() === month && eventDate.getFullYear() === year) {
                    eventDates.add(eventDate.getDate());
                }
            });
            
            // Previous month days
            for (let i = firstDay - 1; i >= 0; i--) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = daysInPrevMonth - i;
                grid.appendChild(dayDiv);
            }
            
            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                dayDiv.textContent = day;
                
                // Highlight today
                if (day === now.getDate()) {
                    dayDiv.classList.add('today');
                }
                
                // Mark days with events
                if (eventDates.has(day)) {
                    dayDiv.classList.add('has-event');
                }
                
                grid.appendChild(dayDiv);
            }
            
            // Next month days to fill grid
            const totalCells = grid.children.length - 7; // Subtract day names
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let day = 1; day <= remainingCells; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = day;
                grid.appendChild(dayDiv);
            }
            
            monthView.appendChild(grid);
            return monthView;
        }
        
        // Render individual event
        function renderEvent(event) {
            const eventDiv = document.createElement('div');
            eventDiv.className = 'calendar-event';
            
            // Add all-day class if applicable
            if (event.isAllDay) {
                eventDiv.classList.add('all-day');
            }
            
            const startDate = new Date(event.start);
            
            // Main info div
            const mainDiv = document.createElement('div');
            
            // Time/date display
            const timeSpan = document.createElement('span');
            timeSpan.className = 'calendar-event-time';
            
            if (event.isAllDay) {
                // For all-day events, show date only
                timeSpan.textContent = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    weekday: 'short'
                });
            } else {
                // For timed events, show date and time
                const dateStr = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric' 
                });
                const timeStr = startDate.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                timeSpan.textContent = `${dateStr} ${timeStr}`;
            }
            mainDiv.appendChild(timeSpan);
            
            // Title
            const titleSpan = document.createElement('span');
            titleSpan.className = 'calendar-event-title';
            titleSpan.textContent = event.title || 'Untitled Event';
            mainDiv.appendChild(titleSpan);
            
            eventDiv.appendChild(mainDiv);
            
            // Location
            if (event.location) {
                const locationDiv = document.createElement('div');
                locationDiv.className = 'calendar-event-location';
                locationDiv.textContent = 'üìç ' + event.location;
                eventDiv.appendChild(locationDiv);
            }
            
            // Description (truncated)
            if (event.description && event.description.trim()) {
                const descDiv = document.createElement('div');
                descDiv.className = 'calendar-event-description';
                // Remove excessive whitespace and limit length
                const cleanDesc = event.description.replace(/\s+/g, ' ').trim();
                descDiv.textContent = cleanDesc.length > 100 ? cleanDesc.substring(0, 100) + '...' : cleanDesc;
                eventDiv.appendChild(descDiv);
            }
            
            return eventDiv;
        }


        // Helper function to convert Celsius to Fahrenheit
        function celsiusToFahrenheit(celsius) {
            return Math.round((celsius * 9/5) + 32);
        }

        // Helper function to convert Fahrenheit to Celsius
        function fahrenheitToCelsius(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5/9);
        }

        // Helper function to get weather icon from OpenWeatherMap icon code
        function getWeatherIcon(iconCode) {
            const iconMap = {
                '01d': '‚òÄÔ∏è', '01n': 'üåô',
                '02d': '‚õÖ', '02n': '‚òÅÔ∏è',
                '03d': '‚òÅÔ∏è', '03n': '‚òÅÔ∏è',
                '04d': '‚òÅÔ∏è', '04n': '‚òÅÔ∏è',
                '09d': 'üåßÔ∏è', '09n': 'üåßÔ∏è',
                '10d': 'üå¶Ô∏è', '10n': 'üåßÔ∏è',
                '11d': '‚õàÔ∏è', '11n': '‚õàÔ∏è',
                '13d': 'üå®Ô∏è', '13n': 'üå®Ô∏è',
                '50d': 'üå´Ô∏è', '50n': 'üå´Ô∏è'
            };
            return iconMap[iconCode] || 'üå§Ô∏è';
        }

        // Update weather widget
        async function updateWeatherWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/weather');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const weather = data.data;
                    const isImperial = weather.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    const tempSecondary = isImperial ? fahrenheitToCelsius(weather.temp) : celsiusToFahrenheit(weather.temp);
                    const secondaryUnit = isImperial ? 'C' : 'F';
                    const windUnit = isImperial ? 'mph' : 'm/s';
                    
                    // Create elements safely
                    content.innerHTML = '';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'weather-icon';
                    iconDiv.textContent = getWeatherIcon(weather.icon);
                    content.appendChild(iconDiv);
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.className = 'weather-temp';
                    tempDiv.textContent = weather.temp + '¬∞';
                    
                    const tempUnitSpan = document.createElement('span');
                    tempUnitSpan.className = 'weather-temp-unit';
                    tempUnitSpan.textContent = tempUnit;
                    tempDiv.appendChild(tempUnitSpan);
                    
                    const tempSecondarySpan = document.createElement('span');
                    tempSecondarySpan.className = 'weather-temp-secondary';
                    tempSecondarySpan.textContent = tempSecondary + '¬∞' + secondaryUnit;
                    tempDiv.appendChild(tempSecondarySpan);
                    content.appendChild(tempDiv);
                    
                    const conditionDiv = document.createElement('div');
                    conditionDiv.className = 'weather-condition';
                    conditionDiv.textContent = weather.description || 'Unknown';
                    content.appendChild(conditionDiv);
                    
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'weather-location';
                    locationDiv.textContent = weather.location + (weather.country ? ', ' + weather.country : '');
                    content.appendChild(locationDiv);
                    
                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'weather-details';
                    
                    const humidityDiv = document.createElement('div');
                    humidityDiv.textContent = 'üíß ' + weather.humidity + '%';
                    detailsDiv.appendChild(humidityDiv);
                    
                    const windDiv = document.createElement('div');
                    windDiv.textContent = 'üí® ' + weather.windSpeed + ' ' + windUnit;
                    detailsDiv.appendChild(windDiv);
                    
                    if (weather.feelsLike) {
                        const feelsLikeSecondary = isImperial ? fahrenheitToCelsius(weather.feelsLike) : celsiusToFahrenheit(weather.feelsLike);
                        const feelsLikeDiv = document.createElement('div');
                        feelsLikeDiv.textContent = 'Feels: ' + weather.feelsLike + '¬∞' + tempUnit;
                        
                        const feelsLikeSecondarySpan = document.createElement('span');
                        feelsLikeSecondarySpan.className = 'weather-feels-like-secondary';
                        feelsLikeSecondarySpan.textContent = ' (' + feelsLikeSecondary + '¬∞' + secondaryUnit + ')';
                        feelsLikeDiv.appendChild(feelsLikeSecondarySpan);
                        
                        detailsDiv.appendChild(feelsLikeDiv);
                    }
                    
                    content.appendChild(detailsDiv);
                } else if (data.error) {
                    const errorContainer = document.createElement('div');
                    errorContainer.style.opacity = '0.6';
                    errorContainer.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = '‚ö†Ô∏è';
                    errorContainer.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorContainer.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorContainer);
                }
            } catch (error) {
                console.error('Error fetching weather:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading weather';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update forecast widget
        async function updateForecastWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/forecast');
                const data = await response.json();
                
                if (data.success && data.days && data.days.length > 0) {
                    const isImperial = data.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    
                    let forecastHTML = '<div class="forecast-container">';
                    data.days.forEach(day => {
                        const tempHigh = day.tempHigh;
                        const tempLow = day.tempLow;
                        const tempHighSecondary = isImperial ? fahrenheitToCelsius(tempHigh) : celsiusToFahrenheit(tempHigh);
                        const tempLowSecondary = isImperial ? fahrenheitToCelsius(tempLow) : celsiusToFahrenheit(tempLow);
                        const secondaryUnit = isImperial ? 'C' : 'F';
                        
                        forecastHTML += `
                            <div class="forecast-day">
                                <div class="forecast-day-name">${day.dayName}</div>
                                <div class="forecast-icon">${getWeatherIcon(day.icon)}</div>
                                <div class="forecast-temp">
                                    <div class="forecast-temp-high">${tempHigh}¬∞${tempUnit}</div>
                                    <div class="forecast-temp-low">${tempLow}¬∞${tempUnit}</div>
                                    <div class="forecast-temp-secondary">
                                        ${tempHighSecondary}¬∞/${tempLowSecondary}¬∞${secondaryUnit}
                                    </div>
                                </div>
                                ${day.precipChance > 0 ? `<div class="forecast-precip">üíß ${day.precipChance}%</div>` : ''}
                            </div>
                        `;
                    });
                    forecastHTML += '</div>';
                    content.innerHTML = forecastHTML;
                } else if (data.error) {
                    content.innerHTML = `<div style="opacity: 0.6; text-align: center;">‚ö†Ô∏è ${data.error}</div>`;
                }
            } catch (error) {
                console.error('Error fetching forecast:', error);
                content.innerHTML = '<div style="opacity: 0.6; text-align: center;">Error loading forecast</div>';
            }
        }

        // Update news widget
        async function updateNewsWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/news');
                const data = await response.json();
                
                if (data.success && data.items && data.items.length > 0) {
                    content.innerHTML = '';
                    const newsContainer = document.createElement('div');
                    newsContainer.className = 'news-items';
                    
                    data.items.slice(0, 5).forEach(item => {
                        const date = item.pubDate ? new Date(item.pubDate).toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric' 
                        }) : '';
                        
                        const newsItem = document.createElement('div');
                        newsItem.className = 'news-item';
                        
                        const title = document.createElement('div');
                        title.className = 'news-title';
                        title.textContent = item.title || 'Untitled';
                        newsItem.appendChild(title);
                        
                        const source = document.createElement('div');
                        source.className = 'news-source';
                        source.textContent = item.source + (date ? ' ‚Ä¢ ' + date : '');
                        newsItem.appendChild(source);
                        
                        newsContainer.appendChild(newsItem);
                    });
                    
                    content.appendChild(newsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.opacity = '0.6';
                    errorDiv.style.textAlign = 'center';
                    errorDiv.textContent = '‚ö†Ô∏è ' + data.error;
                    content.innerHTML = '';
                    content.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.opacity = '0.6';
                    msgDiv.style.textAlign = 'center';
                    msgDiv.textContent = 'No news items available';
                    content.innerHTML = '';
                    content.appendChild(msgDiv);
                }
            } catch (error) {
                console.error('Error fetching news:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading news';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update media widget
        async function updateMediaWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/media');
                const data = await response.json();
                
                if (data.success && data.state && data.state !== 'idle') {
                    content.innerHTML = '';
                    const mediaContainer = document.createElement('div');
                    mediaContainer.className = 'media-container';
                    
                    // Artwork
                    if (data.artworkUrl) {
                        const artworkContainer = document.createElement('div');
                        artworkContainer.className = 'media-artwork-container';
                        
                        const artwork = document.createElement('img');
                        artwork.className = 'media-artwork';
                        artwork.src = data.artworkUrl;
                        artwork.alt = 'Album Artwork';
                        artwork.onerror = () => {
                            artworkContainer.style.display = 'none';
                        };
                        artworkContainer.appendChild(artwork);
                        mediaContainer.appendChild(artworkContainer);
                    }
                    
                    // Media info
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'media-info';
                    
                    if (data.title) {
                        const titleDiv = document.createElement('div');
                        titleDiv.className = 'media-title';
                        titleDiv.textContent = data.title;
                        infoDiv.appendChild(titleDiv);
                    }
                    
                    if (data.artist) {
                        const artistDiv = document.createElement('div');
                        artistDiv.className = 'media-artist';
                        artistDiv.textContent = data.artist;
                        infoDiv.appendChild(artistDiv);
                    }
                    
                    if (data.album) {
                        const albumDiv = document.createElement('div');
                        albumDiv.className = 'media-album';
                        albumDiv.textContent = data.album;
                        infoDiv.appendChild(albumDiv);
                    }
                    
                    // Footer with platform and status
                    const footerDiv = document.createElement('div');
                    footerDiv.className = 'media-footer';
                    
                    const platformDiv = document.createElement('div');
                    platformDiv.className = 'media-platform';
                    platformDiv.textContent = data.platform || 'Media Player';
                    footerDiv.appendChild(platformDiv);
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'media-status';
                    
                    const statusIcon = document.createElement('span');
                    statusIcon.className = 'media-status-icon';
                    
                    if (data.state === 'playing') {
                        statusIcon.textContent = '‚ñ∂Ô∏è';
                        statusDiv.appendChild(statusIcon);
                        const statusText = document.createElement('span');
                        statusText.textContent = 'Playing';
                        statusDiv.appendChild(statusText);
                    } else if (data.state === 'paused') {
                        statusIcon.textContent = '‚è∏Ô∏è';
                        statusDiv.appendChild(statusIcon);
                        const statusText = document.createElement('span');
                        statusText.textContent = 'Paused';
                        statusDiv.appendChild(statusText);
                    } else {
                        statusDiv.textContent = data.state.charAt(0).toUpperCase() + data.state.slice(1);
                    }
                    
                    footerDiv.appendChild(statusDiv);
                    infoDiv.appendChild(footerDiv);
                    
                    mediaContainer.appendChild(infoDiv);
                    content.appendChild(mediaContainer);
                } else if (data.state === 'idle' || data.message) {
                    // Show idle state
                    content.innerHTML = '';
                    const idleDiv = document.createElement('div');
                    idleDiv.className = 'media-idle';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'media-idle-icon';
                    iconDiv.textContent = 'üéµ';
                    idleDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.message || 'No media playing';
                    idleDiv.appendChild(msgDiv);
                    
                    content.appendChild(idleDiv);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.opacity = '0.6';
                    errorDiv.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = '‚ö†Ô∏è';
                    errorDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorDiv.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorDiv);
                }
            } catch (error) {
                console.error('Error fetching media:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading media player';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update vacation widget
        async function updateVacationWidget(content, widgetConfig) {
            // Timezone conversion constants
            const SECONDS_PER_MINUTE = 60;
            const SECONDS_PER_HOUR = 3600;
            const MILLISECONDS_PER_HOUR = 3600000;
            const MIN_TIMEZONE_DIFF_HOURS = 1;
            
            try {
                // Fetch vacation data
                const vacationResponse = await fetch('/api/smart-mirror/vacation');
                const vacationData = await vacationResponse.json();
                
                if (!vacationData.success) {
                    throw new Error(vacationData.error || 'Failed to fetch vacation data');
                }
                
                const vacations = vacationData.vacations || [];
                
                if (vacations.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.style.opacity = '0.6';
                    emptyDiv.style.textAlign = 'center';
                    emptyDiv.style.padding = '20px 0';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = '‚úàÔ∏è';
                    emptyDiv.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = 'No upcoming vacations';
                    emptyDiv.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(emptyDiv);
                    return;
                }
                
                content.innerHTML = '';
                
                // Display up to 3 upcoming vacations
                const displayVacations = vacations.slice(0, 3);
                
                for (const vacation of displayVacations) {
                    const vacationDiv = document.createElement('div');
                    vacationDiv.className = 'vacation-item';
                    vacationDiv.style.marginBottom = '20px';
                    vacationDiv.style.paddingBottom = '15px';
                    vacationDiv.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
                    
                    // Destination header
                    const headerDiv = document.createElement('div');
                    headerDiv.style.display = 'flex';
                    headerDiv.style.alignItems = 'center';
                    headerDiv.style.marginBottom = '8px';
                    
                    const iconSpan = document.createElement('span');
                    iconSpan.style.fontSize = '1.2rem';
                    iconSpan.style.marginRight = '8px';
                    iconSpan.textContent = 'üìç';
                    headerDiv.appendChild(iconSpan);
                    
                    const destDiv = document.createElement('div');
                    destDiv.style.fontSize = '1.1rem';
                    destDiv.style.fontWeight = 'bold';
                    destDiv.textContent = vacation.destination || 'Vacation';
                    headerDiv.appendChild(destDiv);
                    
                    vacationDiv.appendChild(headerDiv);
                    
                    // Dates and countdown
                    const startDate = new Date(vacation.startDate);
                    const endDate = new Date(vacation.endDate);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    const daysUntil = Math.ceil((startDate - today) / (1000 * 60 * 60 * 24));
                    
                    const dateDiv = document.createElement('div');
                    dateDiv.style.fontSize = '0.9rem';
                    dateDiv.style.marginBottom = '5px';
                    dateDiv.textContent = formatDateRange(startDate, endDate);
                    vacationDiv.appendChild(dateDiv);
                    
                    if (daysUntil > 0) {
                        const countdownDiv = document.createElement('div');
                        countdownDiv.style.fontSize = '0.85rem';
                        countdownDiv.style.opacity = '0.8';
                        countdownDiv.style.marginBottom = '8px';
                        countdownDiv.textContent = `üóìÔ∏è ${daysUntil} ${daysUntil === 1 ? 'day' : 'days'} away`;
                        vacationDiv.appendChild(countdownDiv);
                    } else if (daysUntil === 0) {
                        const countdownDiv = document.createElement('div');
                        countdownDiv.style.fontSize = '0.85rem';
                        countdownDiv.style.color = '#4ade80';
                        countdownDiv.style.marginBottom = '8px';
                        countdownDiv.textContent = 'üéâ Today!';
                        vacationDiv.appendChild(countdownDiv);
                    }
                    
                    // Fetch weather and timezone if destination is provided
                    if (vacation.destination && vacation.destination.trim()) {
                        try {
                            // Fetch timezone info
                            const timezoneResponse = await fetch(`/api/smart-mirror/vacation-timezone?location=${encodeURIComponent(vacation.destination)}`);
                            const timezoneData = await timezoneResponse.json();
                            
                            // Display local time if timezone differs from browser timezone
                            if (timezoneData.success && timezoneData.data) {
                                const localOffset = new Date().getTimezoneOffset() * -SECONDS_PER_MINUTE; // Browser offset in seconds
                                const destOffset = timezoneData.data.timezoneOffset;
                                const offsetDiff = (destOffset - localOffset) / SECONDS_PER_HOUR; // Difference in hours
                                
                                if (Math.abs(offsetDiff) >= MIN_TIMEZONE_DIFF_HOURS) {
                                    // Calculate destination time
                                    const now = new Date();
                                    const destTime = new Date(now.getTime() + offsetDiff * MILLISECONDS_PER_HOUR);
                                    
                                    const timeDiv = document.createElement('div');
                                    timeDiv.style.fontSize = '0.85rem';
                                    timeDiv.style.marginBottom = '8px';
                                    timeDiv.style.display = 'flex';
                                    timeDiv.style.alignItems = 'center';
                                    
                                    const clockIcon = document.createElement('span');
                                    clockIcon.textContent = 'üïê ';
                                    clockIcon.style.marginRight = '4px';
                                    timeDiv.appendChild(clockIcon);
                                    
                                    const timeText = document.createElement('span');
                                    timeText.textContent = `Local: ${destTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })} `;
                                    timeDiv.appendChild(timeText);
                                    
                                    const offsetText = document.createElement('span');
                                    offsetText.style.opacity = '0.7';
                                    offsetText.textContent = `(${offsetDiff >= 0 ? '+' : ''}${offsetDiff.toFixed(0)}h)`;
                                    timeDiv.appendChild(offsetText);
                                    
                                    vacationDiv.appendChild(timeDiv);
                                }
                            }
                            
                            // Fetch weather forecast
                            const weatherResponse = await fetch(`/api/smart-mirror/vacation-weather?location=${encodeURIComponent(vacation.destination)}`);
                            const weatherData = await weatherResponse.json();
                            
                            if (weatherData.success && weatherData.days && weatherData.days.length > 0) {
                                const weatherDiv = document.createElement('div');
                                weatherDiv.style.fontSize = '0.85rem';
                                weatherDiv.style.marginTop = '8px';
                                
                                // Find weather for vacation dates
                                const vacationDays = weatherData.days.filter(day => {
                                    const dayDate = new Date(day.date);
                                    return dayDate >= startDate && dayDate <= endDate;
                                });
                                
                                if (vacationDays.length > 0) {
                                    // Show average or first day weather
                                    const firstDay = vacationDays[0];
                                    const weatherIcon = getWeatherIcon(firstDay.icon);
                                    
                                    const weatherContent = document.createElement('div');
                                    weatherContent.style.display = 'flex';
                                    weatherContent.style.alignItems = 'center';
                                    weatherContent.style.gap = '8px';
                                    
                                    const iconSpan = document.createElement('span');
                                    iconSpan.style.fontSize = '1.3rem';
                                    iconSpan.textContent = weatherIcon;
                                    weatherContent.appendChild(iconSpan);
                                    
                                    const tempSpan = document.createElement('span');
                                    tempSpan.textContent = `${firstDay.tempHigh}¬∞ / ${firstDay.tempLow}¬∞`;
                                    weatherContent.appendChild(tempSpan);
                                    
                                    const condSpan = document.createElement('span');
                                    condSpan.style.opacity = '0.8';
                                    condSpan.textContent = firstDay.condition || firstDay.description;
                                    weatherContent.appendChild(condSpan);
                                    
                                    weatherDiv.appendChild(weatherContent);
                                } else if (weatherData.isFallback) {
                                    // Show current weather as fallback
                                    const day = weatherData.days[0];
                                    const weatherIcon = getWeatherIcon(day.icon);
                                    
                                    const weatherContent = document.createElement('div');
                                    weatherContent.style.display = 'flex';
                                    weatherContent.style.alignItems = 'center';
                                    weatherContent.style.gap = '8px';
                                    
                                    const iconSpan = document.createElement('span');
                                    iconSpan.style.fontSize = '1.3rem';
                                    iconSpan.textContent = weatherIcon;
                                    weatherContent.appendChild(iconSpan);
                                    
                                    const tempSpan = document.createElement('span');
                                    tempSpan.textContent = `${day.tempHigh}¬∞`;
                                    weatherContent.appendChild(tempSpan);
                                    
                                    const condSpan = document.createElement('span');
                                    condSpan.style.opacity = '0.8';
                                    condSpan.textContent = day.condition || day.description;
                                    weatherContent.appendChild(condSpan);
                                    
                                    weatherDiv.appendChild(weatherContent);
                                    
                                    const fallbackNote = document.createElement('div');
                                    fallbackNote.style.fontSize = '0.75rem';
                                    fallbackNote.style.opacity = '0.6';
                                    fallbackNote.style.marginTop = '4px';
                                    fallbackNote.textContent = '(Current weather - forecast unavailable)';
                                    weatherDiv.appendChild(fallbackNote);
                                } else {
                                    const noWeatherSpan = document.createElement('span');
                                    noWeatherSpan.style.opacity = '0.6';
                                    noWeatherSpan.textContent = '‚õÖ Weather forecast not available for dates';
                                    weatherDiv.appendChild(noWeatherSpan);
                                }
                                
                                vacationDiv.appendChild(weatherDiv);
                            }
                        } catch (weatherError) {
                            console.error('Error fetching vacation weather/timezone:', weatherError);
                            // Silently fail for weather - don't show error to user
                        }
                    }
                    
                    // Add notes if available
                    if (vacation.notes && vacation.notes.trim()) {
                        const notesDiv = document.createElement('div');
                        notesDiv.style.fontSize = '0.8rem';
                        notesDiv.style.opacity = '0.7';
                        notesDiv.style.marginTop = '8px';
                        notesDiv.style.fontStyle = 'italic';
                        notesDiv.textContent = vacation.notes;
                        vacationDiv.appendChild(notesDiv);
                    }
                    
                    content.appendChild(vacationDiv);
                }
                
            } catch (error) {
                console.error('Error fetching vacation data:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                
                const iconDiv = document.createElement('div');
                iconDiv.style.fontSize = '2rem';
                iconDiv.style.marginBottom = '10px';
                iconDiv.textContent = '‚ö†Ô∏è';
                errorDiv.appendChild(iconDiv);
                
                const msgDiv = document.createElement('div');
                msgDiv.textContent = error.message || 'Error loading vacation data';
                errorDiv.appendChild(msgDiv);
                
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Helper function to format date range
        function formatDateRange(startDate, endDate) {
            const options = { month: 'short', day: 'numeric' };
            const start = startDate.toLocaleDateString('en-US', options);
            const end = endDate.toLocaleDateString('en-US', options);
            
            if (startDate.getFullYear() !== new Date().getFullYear()) {
                return `${start}, ${startDate.getFullYear()} - ${end}, ${endDate.getFullYear()}`;
            }
            
            return `${start} - ${end}`;
        }

        // Show error message
        function showError(message) {
            const container = document.getElementById('dashboardContainer');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            container.innerHTML = '';
            container.appendChild(errorDiv);
        }

        // Initialize dashboard on page load
        let clockInterval = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            
            // Update clock every second
            clockInterval = setInterval(() => {
                if (config && config.widgets && config.widgets.clock && config.widgets.clock.enabled) {
                    const clockElement = document.getElementById('widget-clock');
                    if (clockElement) {
                        updateClockWidget(clockElement);
                    }
                }
            }, 1000);
            
            // Listen for orientation changes (only if not using URL-based orientation)
            if (window.location.pathname !== '/smart-mirror-l' && window.matchMedia) {
                const portraitMedia = window.matchMedia('(orientation: portrait)');
                const landscapeMedia = window.matchMedia('(orientation: landscape)');
                
                const handleOrientationChange = (e) => {
                    const newOrientation = detectOrientation();
                    if (newOrientation !== currentOrientation) {
                        console.log(`[Smart Mirror] Orientation changed: ${currentOrientation} -> ${newOrientation}`);
                        currentOrientation = newOrientation;
                        
                        // Reload config and re-render dashboard
                        loadConfig();
                    }
                };
                
                // Add listeners for both orientations
                portraitMedia.addEventListener('change', handleOrientationChange);
                landscapeMedia.addEventListener('change', handleOrientationChange);
                
                console.log('[Smart Mirror] Orientation change listeners added');
            } else if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Using landscape URL - orientation locked to landscape');
            } else {
                console.log('[Smart Mirror] Using portrait URL - orientation locked to portrait');
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });
    </script>
</body>
</html>
