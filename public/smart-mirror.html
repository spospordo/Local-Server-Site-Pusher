<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Mirror Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body.theme-light {
            background: #f5f5f5;
            color: #333;
        }

        .dashboard-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 20px;
            padding: 20px;
            height: 100vh;
            width: 100vw;
        }

        .widget {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Enforce strict grid sizing - prevent content from expanding widget */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        body.theme-light .widget {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .widget-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .widget-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* Enforce content containment within widget bounds */
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }

        /* Clock Widget */
        .clock-time {
            font-size: 4rem;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .clock-date {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Calendar Widget */
        .calendar-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            /* Ensure calendar container doesn't expand beyond widget */
            min-height: 0;
        }

        .calendar-month-view {
            flex-shrink: 0;
        }

        .calendar-header {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
            text-align: center;
            font-size: 0.85rem;
        }

        .calendar-day-name {
            font-weight: 600;
            padding: 4px 2px;
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .calendar-day {
            padding: 6px 2px;
            border-radius: 4px;
            font-size: 0.85rem;
            min-height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-day.today {
            background: rgba(102, 126, 234, 0.6);
            font-weight: 700;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.4);
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.has-event {
            position: relative;
        }

        .calendar-day.has-event::after {
            content: '‚Ä¢';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(102, 126, 234, 0.8);
            font-size: 0.8rem;
        }

        .calendar-events {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
            min-height: 0; /* Critical for flex child scrolling */
            scroll-behavior: smooth;
        }

        .calendar-events::-webkit-scrollbar {
            width: 6px;
        }

        .calendar-events::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.3);
            border-radius: 3px;
        }

        body.theme-light .calendar-events::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light .calendar-events::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
        }

        .calendar-event {
            background: rgba(102, 126, 234, 0.2);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 0.85rem;
            border-left: 3px solid rgba(102, 126, 234, 0.6);
        }

        .calendar-event.all-day {
            border-left-color: rgba(255, 183, 77, 0.8);
            background: rgba(255, 183, 77, 0.15);
        }

        .calendar-event-time {
            font-weight: 600;
            margin-right: 8px;
            color: rgba(102, 126, 234, 0.9);
        }

        .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 183, 77, 0.9);
        }

        body.theme-light .calendar-event-time {
            color: rgba(102, 126, 234, 1);
        }

        body.theme-light .calendar-event.all-day .calendar-event-time {
            color: rgba(255, 152, 0, 1);
        }

        .calendar-event-title {
            font-weight: 500;
        }

        .calendar-event-location {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 3px;
        }

        .calendar-event-description {
            font-size: 0.75em;
            opacity: 0.6;
            margin-top: 4px;
            line-height: 1.3;
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-error {
            opacity: 0.6;
            text-align: center;
            padding: 10px;
            font-size: 0.9rem;
        }

        .calendar-warning {
            background: rgba(255, 183, 77, 0.2);
            border-left: 3px solid rgba(255, 183, 77, 0.6);
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        /* Responsive calendar layout for different widget sizes */
        @media (min-width: 1px) {
            /* Small widgets - reduce clock size */
            .widget[data-grid-width="1"] .clock-time {
                font-size: 2rem;
            }
            
            .widget[data-grid-width="1"] .clock-date {
                font-size: 0.8rem;
            }
            
            .widget[data-grid-height="1"] .clock-time {
                font-size: 2.5rem;
            }
            
            .widget[data-grid-height="1"] .clock-date {
                font-size: 0.9rem;
            }

            /* Small widgets - reduce calendar grid size */
            .widget[data-grid-width="1"] .calendar-grid,
            .widget[data-grid-height="1"] .calendar-grid {
                font-size: 0.7rem;
                gap: 2px;
            }

            .widget[data-grid-width="1"] .calendar-day,
            .widget[data-grid-height="1"] .calendar-day {
                padding: 3px 1px;
                font-size: 0.7rem;
                min-height: 1.2rem;
            }

            .widget[data-grid-width="1"] .calendar-header,
            .widget[data-grid-height="1"] .calendar-header {
                font-size: 0.9rem;
                margin-bottom: 5px;
            }

            .widget[data-grid-width="1"] .calendar-day-name,
            .widget[data-grid-height="1"] .calendar-day-name {
                font-size: 0.6rem;
            }

            /* Medium and large widgets - standard sizing */
            .widget[data-grid-width="2"] .calendar-events,
            .widget[data-grid-width="3"] .calendar-events,
            .widget[data-grid-width="4"] .calendar-events {
                min-height: 120px;
            }

            /* Wide widgets - use horizontal layout if short */
            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-container,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-container {
                flex-direction: row;
                gap: 15px;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-month-view,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-month-view {
                flex-shrink: 0;
                width: 45%;
            }

            .widget[data-grid-width="3"][data-grid-height="1"] .calendar-events,
            .widget[data-grid-width="4"][data-grid-height="1"] .calendar-events {
                width: 55%;
                min-height: 0;
            }

            /* Responsive weather widget sizing */
            .widget[data-grid-width="1"] .weather-temp {
                font-size: 2rem;
            }
            
            .widget[data-grid-height="1"] .weather-temp {
                font-size: 2.5rem;
            }
            
            .widget[data-grid-width="1"] .weather-condition,
            .widget[data-grid-height="1"] .weather-condition {
                font-size: 1rem;
            }
            
            .widget[data-grid-width="1"] .weather-icon {
                font-size: 1.5rem;
            }

            /* Responsive forecast widget sizing */
            .widget[data-grid-width="2"] .forecast-day-name {
                font-size: 0.9rem;
            }
            
            .widget[data-grid-height="1"] .forecast-icon {
                font-size: 1.5rem;
            }
            
            .widget[data-grid-height="1"] .forecast-temp {
                font-size: 1rem;
            }
        }

        /* Weather Widget */
        .weather-temp {
            font-size: 3rem;
            font-weight: 300;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .weather-temp-unit {
            font-size: 1.5rem;
            opacity: 0.6;
            margin-left: 5px;
        }
        
        .weather-temp-secondary {
            font-size: 1.8rem; /* 60% of 3rem primary temp */
            opacity: 0.5;
            margin-left: 10px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }

        .weather-condition {
            font-size: 1.5rem;
            margin-top: 10px;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .weather-icon {
            font-size: 2.5rem;
            margin: 10px 0;
        }

        .weather-details {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            flex-wrap: wrap;
        }
        
        .weather-location {
            font-size: 1rem;
            opacity: 0.6;
            margin-top: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Forecast Widget */
        .forecast-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 10px;
            /* Use horizontal scroll without wrap for overflow */
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;
        }
        
        .forecast-day {
            text-align: center;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            min-width: 80px; /* Prevent excessive shrinking */
        }
        
        body.theme-light .forecast-day {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .forecast-day-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .forecast-icon {
            font-size: 2rem;
            margin: 8px 0;
        }
        
        .forecast-temp {
            font-size: 1.2rem;
            margin: 5px 0;
        }
        
        .forecast-temp-high {
            font-weight: 600;
        }
        
        .forecast-temp-low {
            opacity: 0.6;
        }
        
        .forecast-precip {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .forecast-temp-secondary {
            font-size: 0.75rem; /* 60-65% of forecast temps */
            opacity: 0.5;
            margin-top: 3px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .forecast-temp-secondary {
            color: #666; /* Darker gray for light theme */
        }
        
        .weather-feels-like-secondary {
            font-size: 0.7rem;
            opacity: 0.5;
            margin-left: 5px;
            color: #888; /* Darker gray for better differentiation */
        }
        
        body.theme-light .weather-feels-like-secondary {
            color: #666; /* Darker gray for light theme */
        }

        /* News Widget */
        .news-items {
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            /* Remove max-height: 100% which can cause expansion */
            flex: 1;
            min-height: 0;
            scroll-behavior: smooth;
        }

        .news-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.theme-light .news-item {
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .news-item:last-child {
            border-bottom: none;
        }

        .news-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 5px;
            /* Truncate long titles */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }

        .news-source {
            font-size: 0.8rem;
            opacity: 0.6;
        }

        /* Error message */
        .error-message {
            color: #ff6b6b;
            padding: 20px;
            text-align: center;
            font-size: 1.2rem;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 20px;
            opacity: 0.6;
        }

        /* Responsive grid positioning - combined position and span rules */
        /* Grid column positioning (x + width) */
        .widget[data-grid-x="0"][data-grid-width="1"] { grid-column: 1 / span 1; }
        .widget[data-grid-x="0"][data-grid-width="2"] { grid-column: 1 / span 2; }
        .widget[data-grid-x="0"][data-grid-width="3"] { grid-column: 1 / span 3; }
        .widget[data-grid-x="0"][data-grid-width="4"] { grid-column: 1 / span 4; }
        
        .widget[data-grid-x="1"][data-grid-width="1"] { grid-column: 2 / span 1; }
        .widget[data-grid-x="1"][data-grid-width="2"] { grid-column: 2 / span 2; }
        .widget[data-grid-x="1"][data-grid-width="3"] { grid-column: 2 / span 3; }
        
        .widget[data-grid-x="2"][data-grid-width="1"] { grid-column: 3 / span 1; }
        .widget[data-grid-x="2"][data-grid-width="2"] { grid-column: 3 / span 2; }
        
        .widget[data-grid-x="3"][data-grid-width="1"] { grid-column: 4 / span 1; }

        /* Grid row positioning (y + height) */
        .widget[data-grid-y="0"][data-grid-height="1"] { grid-row: 1 / span 1; }
        .widget[data-grid-y="0"][data-grid-height="2"] { grid-row: 1 / span 2; }
        .widget[data-grid-y="0"][data-grid-height="3"] { grid-row: 1 / span 3; }
        
        .widget[data-grid-y="1"][data-grid-height="1"] { grid-row: 2 / span 1; }
        .widget[data-grid-y="1"][data-grid-height="2"] { grid-row: 2 / span 2; }
        
        .widget[data-grid-y="2"][data-grid-height="1"] { grid-row: 3 / span 1; }

        /* Scrollbar styling for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        body.theme-light ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        body.theme-light ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
        }

        body.theme-light ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="dashboard-container" id="dashboardContainer">
        <div class="loading">Loading Smart Mirror Dashboard...</div>
    </div>

    <script>
        let config = null;
        let refreshInterval = null;
        let currentOrientation = 'portrait'; // Track current orientation

        // Detect current orientation from URL or screen
        function detectOrientation() {
            // Check URL first
            if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Orientation: landscape (from URL)');
                return 'landscape';
            }
            
            // Try to detect from screen orientation
            try {
                if (window.matchMedia) {
                    // Check if screen is wider than tall (landscape)
                    if (window.matchMedia('(orientation: landscape)').matches) {
                        console.log('[Smart Mirror] Orientation: landscape (from matchMedia)');
                        return 'landscape';
                    } else {
                        console.log('[Smart Mirror] Orientation: portrait (from matchMedia)');
                        return 'portrait';
                    }
                }
            } catch (e) {
                console.warn('[Smart Mirror] matchMedia not available:', e);
            }
            
            // Fallback to comparing dimensions
            if (window.innerWidth > window.innerHeight) {
                console.log('[Smart Mirror] Orientation: landscape (from dimensions)');
                return 'landscape';
            }
            
            console.log('[Smart Mirror] Orientation: portrait (default)');
            return 'portrait';
        }

        // Load configuration and initialize dashboard
        async function loadConfig() {
            console.log('[Smart Mirror] Loading configuration from API...');
            console.log('[Smart Mirror] Timestamp:', new Date().toISOString());
            console.log('[Smart Mirror] User Agent:', navigator.userAgent);
            console.log('[Smart Mirror] Page URL:', window.location.href);
            
            // Detect orientation
            currentOrientation = detectOrientation();
            console.log(`[Smart Mirror] Current orientation: ${currentOrientation}`);
            
            try {
                const fetchStart = performance.now();
                console.log(`[Smart Mirror] Fetching config from /api/smart-mirror/config?orientation=${currentOrientation}`);
                
                const response = await fetch(`/api/smart-mirror/config?orientation=${currentOrientation}`);
                const fetchEnd = performance.now();
                
                console.log(`[Smart Mirror] API response received (${Math.round(fetchEnd - fetchStart)}ms)`);
                console.log('[Smart Mirror] Response status:', response.status, response.statusText);
                console.log('[Smart Mirror] Response headers:', {
                    contentType: response.headers.get('content-type'),
                    cacheControl: response.headers.get('cache-control')
                });
                
                const data = await response.json();
                console.log('[Smart Mirror] Config data parsed:', {
                    success: data.success,
                    hasConfig: !!data.config,
                    enabled: data.config?.enabled,
                    theme: data.config?.theme,
                    widgetCount: Object.keys(data.config?.widgets || {}).length
                });
                
                if (data.success && data.config) {
                    config = data.config;
                    console.log('‚úÖ [Smart Mirror] Config loaded successfully:', config);
                    console.log('[Smart Mirror] Enabled widgets:', 
                        Object.keys(config.widgets || {}).filter(k => config.widgets[k]?.enabled)
                    );
                    
                    // Apply theme
                    if (config.theme === 'light') {
                        console.log('[Smart Mirror] Applying light theme');
                        document.body.classList.add('theme-light');
                    } else {
                        console.log('[Smart Mirror] Using dark theme (default)');
                    }
                    
                    // Check if dashboard is enabled
                    if (config.enabled === false) {
                        console.warn('‚ö†Ô∏è  [Smart Mirror] Dashboard is disabled in configuration');
                        showError('Smart Mirror Dashboard is currently disabled. Please enable it in the admin panel.');
                        return;
                    }
                    
                    console.log('[Smart Mirror] Dashboard is enabled, rendering...');
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Set up refresh interval
                    if (config.refreshInterval && config.refreshInterval > 0) {
                        console.log(`[Smart Mirror] Setting refresh interval: ${config.refreshInterval}ms`);
                        refreshInterval = setInterval(updateWidgets, config.refreshInterval);
                    }
                } else {
                    console.error('‚ùå [Smart Mirror] Config load failed:', data);
                    showError('Failed to load Smart Mirror configuration.');
                }
            } catch (error) {
                console.error('‚ùå [Smart Mirror] Error loading config:', error);
                console.error('[Smart Mirror] Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                showError('Error connecting to server. Please check your connection.');
            }
        }

        // Render the dashboard with configured widgets
        function renderDashboard() {
            console.log('[Smart Mirror] Starting dashboard render');
            const container = document.getElementById('dashboardContainer');
            container.innerHTML = '';

            if (!config || !config.widgets) {
                console.error('‚ùå [Smart Mirror] No widgets configured');
                showError('No widgets configured.');
                return;
            }

            console.log('[Smart Mirror] Rendering widgets:', Object.keys(config.widgets));
            
            // Get the layout for current orientation
            const layout = config.layouts?.[currentOrientation] || {};
            console.log(`[Smart Mirror] Using ${currentOrientation} layout:`, layout);
            
            // Create array of widgets with their keys for sorting
            const widgetEntries = Object.keys(config.widgets)
                .map(widgetKey => ({
                    key: widgetKey,
                    config: config.widgets[widgetKey],
                    layout: layout[widgetKey] || { x: 0, y: 0, width: 1, height: 1 }
                }))
                .filter(entry => entry.config && entry.config.enabled === true);
            
            // Sort widgets by grid position (y first, then x, then by name as tiebreaker)
            widgetEntries.sort((a, b) => {
                const posA = a.layout || { x: 0, y: 0 };
                const posB = b.layout || { x: 0, y: 0 };
                
                // Sort by y coordinate (row) first
                if (posA.y !== posB.y) {
                    return posA.y - posB.y;
                }
                
                // Then by x coordinate (column)
                if (posA.x !== posB.x) {
                    return posA.x - posB.x;
                }
                
                // If same position, sort alphabetically by widget key for stable ordering
                return a.key.localeCompare(b.key);
            });
            
            console.log('[Smart Mirror] Widget render order:', 
                widgetEntries.map(e => `${e.key}(${e.layout?.x},${e.layout?.y})`).join(', ')
            );
            
            // Create widgets based on sorted configuration
            widgetEntries.forEach(entry => {
                const widgetKey = entry.key;
                const widgetConfig = entry.config;
                const widgetLayout = entry.layout;
                
                console.log(`[Smart Mirror] Processing widget: ${widgetKey}`, {
                    enabled: widgetConfig?.enabled,
                    layout: widgetLayout
                });
                
                const widget = createWidget(widgetKey, widgetConfig, widgetLayout);
                if (widget) {
                    container.appendChild(widget);
                }
            });

            // Start updating dynamic content
            updateWidgets();
        }

        // Create a widget element
        function createWidget(type, widgetConfig, widgetLayout) {
            const widget = document.createElement('div');
            widget.className = 'widget';
            widget.dataset.type = type;
            
            // Set grid position from layout
            const pos = widgetLayout || { x: 0, y: 0, width: 1, height: 1 };
            widget.dataset.gridX = pos.x || 0;
            widget.dataset.gridY = pos.y || 0;
            widget.dataset.gridWidth = pos.width || 1;
            widget.dataset.gridHeight = pos.height || 1;

            // Create widget header
            const header = document.createElement('div');
            header.className = 'widget-header';
            header.textContent = getWidgetTitle(type);
            widget.appendChild(header);

            // Create widget content container
            const content = document.createElement('div');
            content.className = 'widget-content';
            content.id = `widget-${type}`;
            widget.appendChild(content);

            return widget;
        }

        // Get widget title
        function getWidgetTitle(type) {
            const titles = {
                clock: 'üïê Time',
                calendar: 'üìÖ Calendar',
                weather: 'üå§Ô∏è Weather',
                forecast: 'üå¶Ô∏è Forecast',
                news: 'üì∞ News'
            };
            return titles[type] || type.charAt(0).toUpperCase() + type.slice(1);
        }

        // Update all dynamic widgets
        function updateWidgets() {
            if (!config || !config.widgets) return;

            Object.keys(config.widgets).forEach(widgetKey => {
                const widgetConfig = config.widgets[widgetKey];
                if (widgetConfig && widgetConfig.enabled === true) {
                    updateWidget(widgetKey, widgetConfig);
                }
            });
        }

        // Update individual widget
        function updateWidget(type, widgetConfig) {
            const content = document.getElementById(`widget-${type}`);
            if (!content) return;

            switch (type) {
                case 'clock':
                    updateClockWidget(content);
                    break;
                case 'calendar':
                    updateCalendarWidget(content, widgetConfig);
                    break;
                case 'weather':
                    updateWeatherWidget(content, widgetConfig);
                    break;
                case 'forecast':
                    updateForecastWidget(content, widgetConfig);
                    break;
                case 'news':
                    updateNewsWidget(content, widgetConfig);
                    break;
            }
        }

        // Update clock widget
        function updateClockWidget(content) {
            const now = new Date();
            
            const timeStr = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            const dateStr = now.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            content.innerHTML = `
                <div class="clock-time">${timeStr}</div>
                <div class="clock-date">${dateStr}</div>
            `;
        }

        // Update calendar widget
        // Update calendar widget
        async function updateCalendarWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/calendar');
                const data = await response.json();
                
                // Clear content
                content.innerHTML = '';
                
                // Create calendar container
                const calendarContainer = document.createElement('div');
                calendarContainer.className = 'calendar-container';
                
                // Generate monthly calendar grid
                const monthView = renderMonthlyCalendar(data.events || []);
                calendarContainer.appendChild(monthView);
                
                // Show warnings if there are errors
                if (data.errors && data.errors.length > 0) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'calendar-warning';
                    warningDiv.textContent = '‚ö†Ô∏è Some feeds could not be loaded';
                    calendarContainer.appendChild(warningDiv);
                }
                
                // Render events list
                if (data.success && data.events && data.events.length > 0) {
                    const eventsContainer = document.createElement('div');
                    eventsContainer.className = 'calendar-events';
                    
                    data.events.forEach(event => {
                        const eventDiv = renderEvent(event);
                        eventsContainer.appendChild(eventDiv);
                    });
                    
                    calendarContainer.appendChild(eventsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'calendar-error';
                    errorDiv.textContent = '‚ö†Ô∏è ' + data.error;
                    calendarContainer.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'calendar-error';
                    msgDiv.textContent = 'No upcoming events';
                    calendarContainer.appendChild(msgDiv);
                }
                
                content.appendChild(calendarContainer);
            } catch (error) {
                console.error('Error fetching calendar:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'calendar-error';
                errorDiv.textContent = 'Error loading calendar';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }
        
        // Render monthly calendar grid
        function renderMonthlyCalendar(events) {
            const monthView = document.createElement('div');
            monthView.className = 'calendar-month-view';
            
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            
            // Create header with month/year
            const header = document.createElement('div');
            header.className = 'calendar-header';
            header.textContent = now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            monthView.appendChild(header);
            
            // Create calendar grid
            const grid = document.createElement('div');
            grid.className = 'calendar-grid';
            
            // Day names
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(day => {
                const dayNameDiv = document.createElement('div');
                dayNameDiv.className = 'calendar-day-name';
                dayNameDiv.textContent = day;
                grid.appendChild(dayNameDiv);
            });
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Create a map of dates with events
            const eventDates = new Set();
            events.forEach(event => {
                const eventDate = new Date(event.start);
                if (eventDate.getMonth() === month && eventDate.getFullYear() === year) {
                    eventDates.add(eventDate.getDate());
                }
            });
            
            // Previous month days
            for (let i = firstDay - 1; i >= 0; i--) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = daysInPrevMonth - i;
                grid.appendChild(dayDiv);
            }
            
            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                dayDiv.textContent = day;
                
                // Highlight today
                if (day === now.getDate()) {
                    dayDiv.classList.add('today');
                }
                
                // Mark days with events
                if (eventDates.has(day)) {
                    dayDiv.classList.add('has-event');
                }
                
                grid.appendChild(dayDiv);
            }
            
            // Next month days to fill grid
            const totalCells = grid.children.length - 7; // Subtract day names
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let day = 1; day <= remainingCells; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.textContent = day;
                grid.appendChild(dayDiv);
            }
            
            monthView.appendChild(grid);
            return monthView;
        }
        
        // Render individual event
        function renderEvent(event) {
            const eventDiv = document.createElement('div');
            eventDiv.className = 'calendar-event';
            
            // Add all-day class if applicable
            if (event.isAllDay) {
                eventDiv.classList.add('all-day');
            }
            
            const startDate = new Date(event.start);
            
            // Main info div
            const mainDiv = document.createElement('div');
            
            // Time/date display
            const timeSpan = document.createElement('span');
            timeSpan.className = 'calendar-event-time';
            
            if (event.isAllDay) {
                // For all-day events, show date only
                timeSpan.textContent = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    weekday: 'short'
                });
            } else {
                // For timed events, show date and time
                const dateStr = startDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric' 
                });
                const timeStr = startDate.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                timeSpan.textContent = `${dateStr} ${timeStr}`;
            }
            mainDiv.appendChild(timeSpan);
            
            // Title
            const titleSpan = document.createElement('span');
            titleSpan.className = 'calendar-event-title';
            titleSpan.textContent = event.title || 'Untitled Event';
            mainDiv.appendChild(titleSpan);
            
            eventDiv.appendChild(mainDiv);
            
            // Location
            if (event.location) {
                const locationDiv = document.createElement('div');
                locationDiv.className = 'calendar-event-location';
                locationDiv.textContent = 'üìç ' + event.location;
                eventDiv.appendChild(locationDiv);
            }
            
            // Description (truncated)
            if (event.description && event.description.trim()) {
                const descDiv = document.createElement('div');
                descDiv.className = 'calendar-event-description';
                // Remove excessive whitespace and limit length
                const cleanDesc = event.description.replace(/\s+/g, ' ').trim();
                descDiv.textContent = cleanDesc.length > 100 ? cleanDesc.substring(0, 100) + '...' : cleanDesc;
                eventDiv.appendChild(descDiv);
            }
            
            return eventDiv;
        }


        // Helper function to convert Celsius to Fahrenheit
        function celsiusToFahrenheit(celsius) {
            return Math.round((celsius * 9/5) + 32);
        }

        // Helper function to convert Fahrenheit to Celsius
        function fahrenheitToCelsius(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5/9);
        }

        // Helper function to get weather icon from OpenWeatherMap icon code
        function getWeatherIcon(iconCode) {
            const iconMap = {
                '01d': '‚òÄÔ∏è', '01n': 'üåô',
                '02d': '‚õÖ', '02n': '‚òÅÔ∏è',
                '03d': '‚òÅÔ∏è', '03n': '‚òÅÔ∏è',
                '04d': '‚òÅÔ∏è', '04n': '‚òÅÔ∏è',
                '09d': 'üåßÔ∏è', '09n': 'üåßÔ∏è',
                '10d': 'üå¶Ô∏è', '10n': 'üåßÔ∏è',
                '11d': '‚õàÔ∏è', '11n': '‚õàÔ∏è',
                '13d': 'üå®Ô∏è', '13n': 'üå®Ô∏è',
                '50d': 'üå´Ô∏è', '50n': 'üå´Ô∏è'
            };
            return iconMap[iconCode] || 'üå§Ô∏è';
        }

        // Update weather widget
        async function updateWeatherWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/weather');
                const data = await response.json();
                
                if (data.success && data.data) {
                    const weather = data.data;
                    const isImperial = weather.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    const tempSecondary = isImperial ? fahrenheitToCelsius(weather.temp) : celsiusToFahrenheit(weather.temp);
                    const secondaryUnit = isImperial ? 'C' : 'F';
                    const windUnit = isImperial ? 'mph' : 'm/s';
                    
                    // Create elements safely
                    content.innerHTML = '';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'weather-icon';
                    iconDiv.textContent = getWeatherIcon(weather.icon);
                    content.appendChild(iconDiv);
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.className = 'weather-temp';
                    tempDiv.textContent = weather.temp + '¬∞';
                    
                    const tempUnitSpan = document.createElement('span');
                    tempUnitSpan.className = 'weather-temp-unit';
                    tempUnitSpan.textContent = tempUnit;
                    tempDiv.appendChild(tempUnitSpan);
                    
                    const tempSecondarySpan = document.createElement('span');
                    tempSecondarySpan.className = 'weather-temp-secondary';
                    tempSecondarySpan.textContent = tempSecondary + '¬∞' + secondaryUnit;
                    tempDiv.appendChild(tempSecondarySpan);
                    content.appendChild(tempDiv);
                    
                    const conditionDiv = document.createElement('div');
                    conditionDiv.className = 'weather-condition';
                    conditionDiv.textContent = weather.description || 'Unknown';
                    content.appendChild(conditionDiv);
                    
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'weather-location';
                    locationDiv.textContent = weather.location + (weather.country ? ', ' + weather.country : '');
                    content.appendChild(locationDiv);
                    
                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'weather-details';
                    
                    const humidityDiv = document.createElement('div');
                    humidityDiv.textContent = 'üíß ' + weather.humidity + '%';
                    detailsDiv.appendChild(humidityDiv);
                    
                    const windDiv = document.createElement('div');
                    windDiv.textContent = 'üí® ' + weather.windSpeed + ' ' + windUnit;
                    detailsDiv.appendChild(windDiv);
                    
                    if (weather.feelsLike) {
                        const feelsLikeSecondary = isImperial ? fahrenheitToCelsius(weather.feelsLike) : celsiusToFahrenheit(weather.feelsLike);
                        const feelsLikeDiv = document.createElement('div');
                        feelsLikeDiv.textContent = 'Feels: ' + weather.feelsLike + '¬∞' + tempUnit;
                        
                        const feelsLikeSecondarySpan = document.createElement('span');
                        feelsLikeSecondarySpan.className = 'weather-feels-like-secondary';
                        feelsLikeSecondarySpan.textContent = ' (' + feelsLikeSecondary + '¬∞' + secondaryUnit + ')';
                        feelsLikeDiv.appendChild(feelsLikeSecondarySpan);
                        
                        detailsDiv.appendChild(feelsLikeDiv);
                    }
                    
                    content.appendChild(detailsDiv);
                } else if (data.error) {
                    const errorContainer = document.createElement('div');
                    errorContainer.style.opacity = '0.6';
                    errorContainer.style.textAlign = 'center';
                    
                    const iconDiv = document.createElement('div');
                    iconDiv.style.fontSize = '2rem';
                    iconDiv.style.marginBottom = '10px';
                    iconDiv.textContent = '‚ö†Ô∏è';
                    errorContainer.appendChild(iconDiv);
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.textContent = data.error;
                    errorContainer.appendChild(msgDiv);
                    
                    content.innerHTML = '';
                    content.appendChild(errorContainer);
                }
            } catch (error) {
                console.error('Error fetching weather:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading weather';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Update forecast widget
        async function updateForecastWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/forecast');
                const data = await response.json();
                
                if (data.success && data.days && data.days.length > 0) {
                    const isImperial = data.units === 'imperial';
                    const tempUnit = isImperial ? 'F' : 'C';
                    
                    let forecastHTML = '<div class="forecast-container">';
                    data.days.forEach(day => {
                        const tempHigh = day.tempHigh;
                        const tempLow = day.tempLow;
                        const tempHighSecondary = isImperial ? fahrenheitToCelsius(tempHigh) : celsiusToFahrenheit(tempHigh);
                        const tempLowSecondary = isImperial ? fahrenheitToCelsius(tempLow) : celsiusToFahrenheit(tempLow);
                        const secondaryUnit = isImperial ? 'C' : 'F';
                        
                        forecastHTML += `
                            <div class="forecast-day">
                                <div class="forecast-day-name">${day.dayName}</div>
                                <div class="forecast-icon">${getWeatherIcon(day.icon)}</div>
                                <div class="forecast-temp">
                                    <div class="forecast-temp-high">${tempHigh}¬∞${tempUnit}</div>
                                    <div class="forecast-temp-low">${tempLow}¬∞${tempUnit}</div>
                                    <div class="forecast-temp-secondary">
                                        ${tempHighSecondary}¬∞/${tempLowSecondary}¬∞${secondaryUnit}
                                    </div>
                                </div>
                                ${day.precipChance > 0 ? `<div class="forecast-precip">üíß ${day.precipChance}%</div>` : ''}
                            </div>
                        `;
                    });
                    forecastHTML += '</div>';
                    content.innerHTML = forecastHTML;
                } else if (data.error) {
                    content.innerHTML = `<div style="opacity: 0.6; text-align: center;">‚ö†Ô∏è ${data.error}</div>`;
                }
            } catch (error) {
                console.error('Error fetching forecast:', error);
                content.innerHTML = '<div style="opacity: 0.6; text-align: center;">Error loading forecast</div>';
            }
        }

        // Update news widget
        async function updateNewsWidget(content, widgetConfig) {
            try {
                const response = await fetch('/api/smart-mirror/news');
                const data = await response.json();
                
                if (data.success && data.items && data.items.length > 0) {
                    content.innerHTML = '';
                    const newsContainer = document.createElement('div');
                    newsContainer.className = 'news-items';
                    
                    data.items.slice(0, 5).forEach(item => {
                        const date = item.pubDate ? new Date(item.pubDate).toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric' 
                        }) : '';
                        
                        const newsItem = document.createElement('div');
                        newsItem.className = 'news-item';
                        
                        const title = document.createElement('div');
                        title.className = 'news-title';
                        title.textContent = item.title || 'Untitled';
                        newsItem.appendChild(title);
                        
                        const source = document.createElement('div');
                        source.className = 'news-source';
                        source.textContent = item.source + (date ? ' ‚Ä¢ ' + date : '');
                        newsItem.appendChild(source);
                        
                        newsContainer.appendChild(newsItem);
                    });
                    
                    content.appendChild(newsContainer);
                } else if (data.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.opacity = '0.6';
                    errorDiv.style.textAlign = 'center';
                    errorDiv.textContent = '‚ö†Ô∏è ' + data.error;
                    content.innerHTML = '';
                    content.appendChild(errorDiv);
                } else {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.opacity = '0.6';
                    msgDiv.style.textAlign = 'center';
                    msgDiv.textContent = 'No news items available';
                    content.innerHTML = '';
                    content.appendChild(msgDiv);
                }
            } catch (error) {
                console.error('Error fetching news:', error);
                const errorDiv = document.createElement('div');
                errorDiv.style.opacity = '0.6';
                errorDiv.style.textAlign = 'center';
                errorDiv.textContent = 'Error loading news';
                content.innerHTML = '';
                content.appendChild(errorDiv);
            }
        }

        // Show error message
        function showError(message) {
            const container = document.getElementById('dashboardContainer');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            container.innerHTML = '';
            container.appendChild(errorDiv);
        }

        // Initialize dashboard on page load
        let clockInterval = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            
            // Update clock every second
            clockInterval = setInterval(() => {
                if (config && config.widgets && config.widgets.clock && config.widgets.clock.enabled) {
                    const clockElement = document.getElementById('widget-clock');
                    if (clockElement) {
                        updateClockWidget(clockElement);
                    }
                }
            }, 1000);
            
            // Listen for orientation changes (only if not using URL-based orientation)
            if (window.location.pathname !== '/smart-mirror-l' && window.matchMedia) {
                const portraitMedia = window.matchMedia('(orientation: portrait)');
                const landscapeMedia = window.matchMedia('(orientation: landscape)');
                
                const handleOrientationChange = (e) => {
                    const newOrientation = detectOrientation();
                    if (newOrientation !== currentOrientation) {
                        console.log(`[Smart Mirror] Orientation changed: ${currentOrientation} -> ${newOrientation}`);
                        currentOrientation = newOrientation;
                        
                        // Reload config and re-render dashboard
                        loadConfig();
                    }
                };
                
                // Add listeners for both orientations
                portraitMedia.addEventListener('change', handleOrientationChange);
                landscapeMedia.addEventListener('change', handleOrientationChange);
                
                console.log('[Smart Mirror] Orientation change listeners added');
            } else if (window.location.pathname === '/smart-mirror-l') {
                console.log('[Smart Mirror] Using landscape URL - orientation locked to landscape');
            } else {
                console.log('[Smart Mirror] Using portrait URL - orientation locked to portrait');
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
            if (clockInterval) {
                clearInterval(clockInterval);
            }
        });
    </script>
</body>
</html>
